<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Processor Counter Monitor: PCM Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Processor Counter Monitor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classPCM-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PCM Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>CPU Performance Monitor.  
 <a href="classPCM.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cpucounters_8h_source.html">cpucounters.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPCM_1_1CustomCoreEventDescription.html">CustomCoreEventDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom <a class="el" href="classCore.html">Core</a> event description.  <a href="structPCM_1_1CustomCoreEventDescription.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPCM_1_1CustomIIOEventDescription.html">CustomIIOEventDescription</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPCM_1_1ExtendedCustomCoreEventDescription.html">ExtendedCustomCoreEventDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended custom core event description.  <a href="structPCM_1_1ExtendedCustomCoreEventDescription.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPCM_1_1SimplePCIeDevInfo.html">SimplePCIeDevInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6bc57e347e286d0299c9329f37bb7b64"><td class="memItemLeft" align="right" valign="top"><a id="a6bc57e347e286d0299c9329f37bb7b64"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>MAX_C_STATE</b> = 10
 }</td></tr>
<tr class="separator:a6bc57e347e286d0299c9329f37bb7b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88584813a3ef51376efeb22928764786"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786">ProgramMode</a> { <a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786a0e861144f482697cfa423b012ed42451">DEFAULT_EVENTS</a> = 0, 
<a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786ac092b2b5f351e33046b87e5cee31f38f">CUSTOM_CORE_EVENTS</a> = 1, 
<a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786a0f2ff80b85b8f9483c7f03544f73fcbd">EXT_CUSTOM_CORE_EVENTS</a> = 2, 
<a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786ad60e2f3b64e27eaaa84d2b07fea8e225">INVALID_MODE</a>
 }<tr class="memdesc:a88584813a3ef51376efeb22928764786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mode of programming (parameter in the <a class="el" href="classPCM.html#abae9577a1a172c944d133bef10683825" title="Programs performance counters. ">program()</a> method)  <a href="classPCM.html#a88584813a3ef51376efeb22928764786">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a88584813a3ef51376efeb22928764786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebf5f22d794719dfc49155741e264e5"><td class="memItemLeft" align="right" valign="top"><a id="abebf5f22d794719dfc49155741e264e5"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#abebf5f22d794719dfc49155741e264e5">ErrorCode</a> { <b>Success</b> = 0, 
<b>MSRAccessDenied</b> = 1, 
<b>PMUBusy</b> = 2, 
<b>UnknownError</b>
 }<tr class="memdesc:abebf5f22d794719dfc49155741e264e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return codes (e.g. for program(..) method) <br /></td></tr>
</td></tr>
<tr class="separator:abebf5f22d794719dfc49155741e264e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e729e5eba43d92e18495fc721e981fe"><td class="memItemLeft" align="right" valign="top"><a id="a4e729e5eba43d92e18495fc721e981fe"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PerfmonField</b> { <br />
&#160;&#160;<b>INVALID</b>, 
<b>OPCODE</b>, 
<b>EVENT_SELECT</b>, 
<b>UMASK</b>, 
<br />
&#160;&#160;<b>RESET</b>, 
<b>EDGE_DET</b>, 
<b>IGNORED</b>, 
<b>OVERFLOW_ENABLE</b>, 
<br />
&#160;&#160;<b>ENABLE</b>, 
<b>INVERT</b>, 
<b>THRESH</b>, 
<b>CH_MASK</b>, 
<br />
&#160;&#160;<b>FC_MASK</b>, 
<b>H_EVENT_NAME</b>, 
<b>V_EVENT_NAME</b>, 
<b>MULTIPLIER</b>, 
<br />
&#160;&#160;<b>DIVIDER</b>, 
<b>COUNTER_INDEX</b>
<br />
 }</td></tr>
<tr class="separator:a4e729e5eba43d92e18495fc721e981fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b95584dd1ea84c9f005dd0413c1dd0f"><td class="memItemLeft" align="right" valign="top"><a id="a8b95584dd1ea84c9f005dd0413c1dd0f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PCIeWidthMode</b> { <br />
&#160;&#160;<b>X1</b>, 
<b>X4</b>, 
<b>X8</b>, 
<b>X16</b>, 
<br />
&#160;&#160;<b>XFF</b>
<br />
 }</td></tr>
<tr class="separator:a8b95584dd1ea84c9f005dd0413c1dd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b837ca75e898ec0fa4017c9a8b17ca"><td class="memItemLeft" align="right" valign="top"><a id="a00b837ca75e898ec0fa4017c9a8b17ca"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>IIO_CBDMA</b> = 0, 
<b>IIO_PCIe0</b> = 1, 
<b>IIO_PCIe1</b> = 2, 
<b>IIO_PCIe2</b> = 3, 
<br />
&#160;&#160;<b>IIO_MCP0</b> = 4, 
<b>IIO_MCP1</b> = 5, 
<b>IIO_STACK_COUNT</b> = 6
<br />
 }</td></tr>
<tr class="separator:a00b837ca75e898ec0fa4017c9a8b17ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488da180e8be92363ba7c731460ad762"><td class="memItemLeft" align="right" valign="top"><a id="a488da180e8be92363ba7c731460ad762"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>EventPosition</b> { <b>TOR_OCCUPANCY</b> = 0, 
<b>TOR_INSERTS</b> = 1, 
<b>REQUESTS_ALL</b> = 2, 
<b>REQUESTS_LOCAL</b> = 3
 }</td></tr>
<tr class="separator:a488da180e8be92363ba7c731460ad762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca50e5907ef2b7cf7c81a5e069135f7"><td class="memItemLeft" align="right" valign="top"><a id="a7ca50e5907ef2b7cf7c81a5e069135f7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a7ca50e5907ef2b7cf7c81a5e069135f7">SupportedCPUModels</a> { <br />
&#160;&#160;<b>NEHALEM_EP</b> = 26, 
<b>NEHALEM</b> = 30, 
<b>ATOM</b> = 28, 
<b>ATOM_2</b> = 53, 
<br />
&#160;&#160;<b>CENTERTON</b> = 54, 
<b>BAYTRAIL</b> = 55, 
<b>AVOTON</b> = 77, 
<b>CHERRYTRAIL</b> = 76, 
<br />
&#160;&#160;<b>APOLLO_LAKE</b> = 92, 
<b>DENVERTON</b> = 95, 
<b>CLARKDALE</b> = 37, 
<b>WESTMERE_EP</b> = 44, 
<br />
&#160;&#160;<b>NEHALEM_EX</b> = 46, 
<b>WESTMERE_EX</b> = 47, 
<b>SANDY_BRIDGE</b> = 42, 
<b>JAKETOWN</b> = 45, 
<br />
&#160;&#160;<b>IVY_BRIDGE</b> = 58, 
<b>HASWELL</b> = 60, 
<b>HASWELL_ULT</b> = 69, 
<b>HASWELL_2</b> = 70, 
<br />
&#160;&#160;<b>IVYTOWN</b> = 62, 
<b>HASWELLX</b> = 63, 
<b>BROADWELL</b> = 61, 
<b>BROADWELL_XEON_E3</b> = 71, 
<br />
&#160;&#160;<b>BDX_DE</b> = 86, 
<b>SKL_UY</b> = 78, 
<b>KBL</b> = 158, 
<b>KBL_1</b> = 142, 
<br />
&#160;&#160;<b>BDX</b> = 79, 
<b>KNL</b> = 87, 
<b>SKL</b> = 94, 
<b>SKX</b> = 85, 
<br />
&#160;&#160;<b>END_OF_MODEL_LIST</b> = 0x0ffff
<br />
 }<tr class="memdesc:a7ca50e5907ef2b7cf7c81a5e069135f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifiers of supported CPU models. <br /></td></tr>
</td></tr>
<tr class="separator:a7ca50e5907ef2b7cf7c81a5e069135f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b8031a61ae839bdd021ee7b56aa585"><td class="memItemLeft" align="right" valign="top"><a id="a77b8031a61ae839bdd021ee7b56aa585"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PCIeEventCode</b> { <br />
&#160;&#160;<b>PCIeRdCur</b> = 0x19E, 
<b>PCIeNSRd</b> = 0x1E4, 
<b>PCIeWiLF</b> = 0x194, 
<b>PCIeItoM</b> = 0x19C, 
<br />
&#160;&#160;<b>PCIeNSWr</b> = 0x1E5, 
<b>PCIeNSWrF</b> = 0x1E6, 
<b>RFO</b> = 0x180, 
<b>CRd</b> = 0x181, 
<br />
&#160;&#160;<b>DRd</b> = 0x182, 
<b>PRd</b> = 0x187, 
<b>WiL</b> = 0x18F, 
<b>ItoM</b> = 0x1C8, 
<br />
&#160;&#160;<b>SKX_RFO</b> = 0x200, 
<b>SKX_CRd</b> = 0x201, 
<b>SKX_DRd</b> = 0x202, 
<b>SKX_PRd</b> = 0x207, 
<br />
&#160;&#160;<b>SKX_WiL</b> = 0x20F, 
<b>SKX_RdCur</b> = 0x21E, 
<b>SKX_ItoM</b> = 0x248
<br />
 }</td></tr>
<tr class="separator:a77b8031a61ae839bdd021ee7b56aa585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd71939913b70911ed3d076b07e18308"><td class="memItemLeft" align="right" valign="top"><a id="afd71939913b70911ed3d076b07e18308"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ChaPipelineQueue</b> { <b>None</b>, 
<b>IRQ</b>, 
<b>PRQ</b>
 }</td></tr>
<tr class="separator:afd71939913b70911ed3d076b07e18308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c72526891bf528aaf85b18103c7b07b"><td class="memItemLeft" align="right" valign="top"><a id="a6c72526891bf528aaf85b18103c7b07b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>CBoEventTid</b> { <b>RFOtid</b> = 0x3E, 
<b>ItoMtid</b> = 0x3E
 }</td></tr>
<tr class="separator:a6c72526891bf528aaf85b18103c7b07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af43f3a1e920264467a3855ced5f8162b"><td class="memItemLeft" align="right" valign="top"><a id="af43f3a1e920264467a3855ced5f8162b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#af43f3a1e920264467a3855ced5f8162b">isCoreCStateResidencySupported</a> (int state)</td></tr>
<tr class="memdesc:af43f3a1e920264467a3855ced5f8162b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified core C-state residency metric is supported. <br /></td></tr>
<tr class="separator:af43f3a1e920264467a3855ced5f8162b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad05d8a2f383ad41d25892175373b613"><td class="memItemLeft" align="right" valign="top"><a id="aad05d8a2f383ad41d25892175373b613"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#aad05d8a2f383ad41d25892175373b613">isPackageCStateResidencySupported</a> (int state)</td></tr>
<tr class="memdesc:aad05d8a2f383ad41d25892175373b613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified package C-state residency metric is supported. <br /></td></tr>
<tr class="separator:aad05d8a2f383ad41d25892175373b613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab4b857581f55723fc3959cf6c8cd91"><td class="memItemLeft" align="right" valign="top"><a id="aaab4b857581f55723fc3959cf6c8cd91"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#aaab4b857581f55723fc3959cf6c8cd91">setOutput</a> (const std::string filename)</td></tr>
<tr class="memdesc:aaab4b857581f55723fc3959cf6c8cd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirects output destination to provided file, instead of std::cout. <br /></td></tr>
<tr class="separator:aaab4b857581f55723fc3959cf6c8cd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bcd9d89ee64d8effdf968132f3b842"><td class="memItemLeft" align="right" valign="top"><a id="af8bcd9d89ee64d8effdf968132f3b842"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#af8bcd9d89ee64d8effdf968132f3b842">restoreOutput</a> ()</td></tr>
<tr class="memdesc:af8bcd9d89ee64d8effdf968132f3b842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores output, closes output file if opened. <br /></td></tr>
<tr class="separator:af8bcd9d89ee64d8effdf968132f3b842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5b4989751f87a17649810a964fa053"><td class="memItemLeft" align="right" valign="top"><a id="adb5b4989751f87a17649810a964fa053"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#adb5b4989751f87a17649810a964fa053">setRunState</a> (int new_state)</td></tr>
<tr class="memdesc:adb5b4989751f87a17649810a964fa053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Run State. <br /></td></tr>
<tr class="separator:adb5b4989751f87a17649810a964fa053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc8a2d2073ce855558d201883ecf3cd"><td class="memItemLeft" align="right" valign="top"><a id="a5fc8a2d2073ce855558d201883ecf3cd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a5fc8a2d2073ce855558d201883ecf3cd">getRunState</a> (void)</td></tr>
<tr class="memdesc:a5fc8a2d2073ce855558d201883ecf3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns program's Run State. <br /></td></tr>
<tr class="separator:a5fc8a2d2073ce855558d201883ecf3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab665ed42ffe2818dbc4f44e6b7ea5436"><td class="memItemLeft" align="right" valign="top"><a id="ab665ed42ffe2818dbc4f44e6b7ea5436"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isBlocked</b> (void)</td></tr>
<tr class="separator:ab665ed42ffe2818dbc4f44e6b7ea5436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61cae141755617819b1a81d5fac91d3"><td class="memItemLeft" align="right" valign="top"><a id="ad61cae141755617819b1a81d5fac91d3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setBlocked</b> (const bool new_blocked)</td></tr>
<tr class="separator:ad61cae141755617819b1a81d5fac91d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4261a7c1980c16cfe289856401aa3bee"><td class="memItemLeft" align="right" valign="top"><a id="a4261a7c1980c16cfe289856401aa3bee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a4261a7c1980c16cfe289856401aa3bee">allowMultipleInstances</a> ()</td></tr>
<tr class="memdesc:a4261a7c1980c16cfe289856401aa3bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call it before <a class="el" href="classPCM.html#abae9577a1a172c944d133bef10683825" title="Programs performance counters. ">program()</a> to allow multiple running instances of <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> on the same system. <br /></td></tr>
<tr class="separator:a4261a7c1980c16cfe289856401aa3bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af93b231edbc31952b3b46799c28a10"><td class="memItemLeft" align="right" valign="top"><a id="a8af93b231edbc31952b3b46799c28a10"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a8af93b231edbc31952b3b46799c28a10">isSecureBoot</a> () const</td></tr>
<tr class="memdesc:a8af93b231edbc31952b3b46799c28a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if in secure boot mode <br /></td></tr>
<tr class="separator:a8af93b231edbc31952b3b46799c28a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186e0ed6648ca7a078c658020ca8d6e2"><td class="memItemLeft" align="right" valign="top"><a id="a186e0ed6648ca7a078c658020ca8d6e2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a186e0ed6648ca7a078c658020ca8d6e2">useLinuxPerfForUncore</a> () const</td></tr>
<tr class="memdesc:a186e0ed6648ca7a078c658020ca8d6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if Linux perf for uncore PMU programming should AND can be used internally <br /></td></tr>
<tr class="separator:a186e0ed6648ca7a078c658020ca8d6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23a4c0feeda389a1e56191a5740f95a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSystemRoot.html">SystemRoot</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ad23a4c0feeda389a1e56191a5740f95a">getSystemTopology</a> () const</td></tr>
<tr class="memdesc:ad23a4c0feeda389a1e56191a5740f95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The system, sockets, uncores, cores and threads are structured like a tree.  <a href="#ad23a4c0feeda389a1e56191a5740f95a">More...</a><br /></td></tr>
<tr class="separator:ad23a4c0feeda389a1e56191a5740f95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12300d8a7096cc4258108ced23cd491"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ad12300d8a7096cc4258108ced23cd491">QOSMetricAvailable</a> () const</td></tr>
<tr class="memdesc:ad12300d8a7096cc4258108ced23cd491"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if QOS monitoring support present  <a href="#ad12300d8a7096cc4258108ced23cd491">More...</a><br /></td></tr>
<tr class="separator:ad12300d8a7096cc4258108ced23cd491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1be879d2c871816ddbcfa30bb58a3e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ab1be879d2c871816ddbcfa30bb58a3e7">L3QOSMetricAvailable</a> () const</td></tr>
<tr class="memdesc:ab1be879d2c871816ddbcfa30bb58a3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks L3 cache support for QOS present  <a href="#ab1be879d2c871816ddbcfa30bb58a3e7">More...</a><br /></td></tr>
<tr class="separator:ab1be879d2c871816ddbcfa30bb58a3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6580b296a5a0236c9e00956988c0fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a6a6580b296a5a0236c9e00956988c0fc">L3CacheOccupancyMetricAvailable</a> () const</td></tr>
<tr class="memdesc:a6a6580b296a5a0236c9e00956988c0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if L3 cache monitoring present  <a href="#a6a6580b296a5a0236c9e00956988c0fc">More...</a><br /></td></tr>
<tr class="separator:a6a6580b296a5a0236c9e00956988c0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0648834f063a6bd2ea88c61a2ba286d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#af0648834f063a6bd2ea88c61a2ba286d">CoreLocalMemoryBWMetricAvailable</a> () const</td></tr>
<tr class="memdesc:af0648834f063a6bd2ea88c61a2ba286d"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if local memory bandwidth monitoring present  <a href="#af0648834f063a6bd2ea88c61a2ba286d">More...</a><br /></td></tr>
<tr class="separator:af0648834f063a6bd2ea88c61a2ba286d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2b73d2af7c5a851e5c43df37d7fdb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a9b2b73d2af7c5a851e5c43df37d7fdb2">CoreRemoteMemoryBWMetricAvailable</a> () const</td></tr>
<tr class="memdesc:a9b2b73d2af7c5a851e5c43df37d7fdb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if total memory bandwidth monitoring present  <a href="#a9b2b73d2af7c5a851e5c43df37d7fdb2">More...</a><br /></td></tr>
<tr class="separator:a9b2b73d2af7c5a851e5c43df37d7fdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1151b2a215849ab67ab2b0056e0e0f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a0e1151b2a215849ab67ab2b0056e0e0f">getMaxRMID</a> () const</td></tr>
<tr class="memdesc:a0e1151b2a215849ab67ab2b0056e0e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the max number of RMID supported by socket  <a href="#a0e1151b2a215849ab67ab2b0056e0e0f">More...</a><br /></td></tr>
<tr class="separator:a0e1151b2a215849ab67ab2b0056e0e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56eedaa84893f72b1723f8d580ee3329"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a56eedaa84893f72b1723f8d580ee3329">good</a> ()</td></tr>
<tr class="memdesc:a56eedaa84893f72b1723f8d580ee3329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the status of <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> object.  <a href="#a56eedaa84893f72b1723f8d580ee3329">More...</a><br /></td></tr>
<tr class="separator:a56eedaa84893f72b1723f8d580ee3329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb527aac9b4a15b5437bbfc3111cdeb"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#afbb527aac9b4a15b5437bbfc3111cdeb">getErrorMessage</a> () const</td></tr>
<tr class="memdesc:afbb527aac9b4a15b5437bbfc3111cdeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error message.  <a href="#afbb527aac9b4a15b5437bbfc3111cdeb">More...</a><br /></td></tr>
<tr class="separator:afbb527aac9b4a15b5437bbfc3111cdeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae9577a1a172c944d133bef10683825"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPCM.html#abebf5f22d794719dfc49155741e264e5">ErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#abae9577a1a172c944d133bef10683825">program</a> (const <a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786">ProgramMode</a> mode_=<a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786a0e861144f482697cfa423b012ed42451">DEFAULT_EVENTS</a>, const void *parameter_=NULL)</td></tr>
<tr class="memdesc:abae9577a1a172c944d133bef10683825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs performance counters.  <a href="#abae9577a1a172c944d133bef10683825">More...</a><br /></td></tr>
<tr class="separator:abae9577a1a172c944d133bef10683825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66009c229b17597aba8d1e51db274840"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPCM.html#abebf5f22d794719dfc49155741e264e5">ErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a66009c229b17597aba8d1e51db274840">programServerUncoreLatencyMetrics</a> (bool enable_pmm)</td></tr>
<tr class="memdesc:a66009c229b17597aba8d1e51db274840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs uncore latency counters on microarchitectures codename SandyBridge-EP and later Xeon uarch.  <a href="#a66009c229b17597aba8d1e51db274840">More...</a><br /></td></tr>
<tr class="separator:a66009c229b17597aba8d1e51db274840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a30cec6e4e7a78ec964d194e3844637"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPCM.html#abebf5f22d794719dfc49155741e264e5">ErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a3a30cec6e4e7a78ec964d194e3844637">programServerUncorePowerMetrics</a> (int mc_profile, int pcu_profile, int *freq_bands=NULL)</td></tr>
<tr class="memdesc:a3a30cec6e4e7a78ec964d194e3844637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs uncore power/energy counters on microarchitectures codename SandyBridge-EP and later Xeon uarch.  <a href="#a3a30cec6e4e7a78ec964d194e3844637">More...</a><br /></td></tr>
<tr class="separator:a3a30cec6e4e7a78ec964d194e3844637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9927f044c832bbdcd369c7bc1ad986c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPCM.html#abebf5f22d794719dfc49155741e264e5">ErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a9927f044c832bbdcd369c7bc1ad986c6">programServerUncoreMemoryMetrics</a> (int rankA=-1, int rankB=-1, bool PMM=false, bool PMMMixedMode=false)</td></tr>
<tr class="memdesc:a9927f044c832bbdcd369c7bc1ad986c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs uncore memory counters on microarchitectures codename SandyBridge-EP and later Xeon uarch.  <a href="#a9927f044c832bbdcd369c7bc1ad986c6">More...</a><br /></td></tr>
<tr class="separator:a9927f044c832bbdcd369c7bc1ad986c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f142010bb99ba6b81e93895bfa20252"><td class="memItemLeft" align="right" valign="top"><a id="a9f142010bb99ba6b81e93895bfa20252"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a9f142010bb99ba6b81e93895bfa20252">freezeServerUncoreCounters</a> ()</td></tr>
<tr class="memdesc:a9f142010bb99ba6b81e93895bfa20252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Freezes uncore event counting (works only on microarchitecture codename SandyBridge-EP and IvyTown) <br /></td></tr>
<tr class="separator:a9f142010bb99ba6b81e93895bfa20252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617beda55da4de32593a7aa925fe1f02"><td class="memItemLeft" align="right" valign="top"><a id="a617beda55da4de32593a7aa925fe1f02"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a617beda55da4de32593a7aa925fe1f02">unfreezeServerUncoreCounters</a> ()</td></tr>
<tr class="memdesc:a617beda55da4de32593a7aa925fe1f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unfreezes uncore event counting (works only on microarchitecture codename SandyBridge-EP and IvyTown) <br /></td></tr>
<tr class="separator:a617beda55da4de32593a7aa925fe1f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348909c5eee3df734c1784105fb97581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classServerUncoreCounterState.html">ServerUncoreCounterState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a348909c5eee3df734c1784105fb97581">getServerUncoreCounterState</a> (uint32 socket)</td></tr>
<tr class="memdesc:a348909c5eee3df734c1784105fb97581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the power/energy counter state of a socket (works only on microarchitecture codename SandyBridge-EP)  <a href="#a348909c5eee3df734c1784105fb97581">More...</a><br /></td></tr>
<tr class="separator:a348909c5eee3df734c1784105fb97581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c8d3764ff95840ece17d632de4df9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ac0c8d3764ff95840ece17d632de4df9b">cleanup</a> ()</td></tr>
<tr class="memdesc:ac0c8d3764ff95840ece17d632de4df9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanups resources and stops performance counting.  <a href="#ac0c8d3764ff95840ece17d632de4df9b">More...</a><br /></td></tr>
<tr class="separator:ac0c8d3764ff95840ece17d632de4df9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f5ff2c6ce12f0fb4bb5ae1e5bd157a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ad4f5ff2c6ce12f0fb4bb5ae1e5bd157a">resetPMU</a> ()</td></tr>
<tr class="memdesc:ad4f5ff2c6ce12f0fb4bb5ae1e5bd157a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces PMU reset.  <a href="#ad4f5ff2c6ce12f0fb4bb5ae1e5bd157a">More...</a><br /></td></tr>
<tr class="separator:ad4f5ff2c6ce12f0fb4bb5ae1e5bd157a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade92d30321a659ca54d423eaf0e30e12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ade92d30321a659ca54d423eaf0e30e12">getAllCounterStates</a> (<a class="el" href="classSystemCounterState.html">SystemCounterState</a> &amp;systemState, std::vector&lt; <a class="el" href="classSocketCounterState.html">SocketCounterState</a> &gt; &amp;socketStates, std::vector&lt; <a class="el" href="classCoreCounterState.html">CoreCounterState</a> &gt; &amp;coreStates)</td></tr>
<tr class="memdesc:ade92d30321a659ca54d423eaf0e30e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads all counter states (including system, sockets and cores)  <a href="#ade92d30321a659ca54d423eaf0e30e12">More...</a><br /></td></tr>
<tr class="separator:ade92d30321a659ca54d423eaf0e30e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1ffc2220b041f739a672b5be82361f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a9f1ffc2220b041f739a672b5be82361f">getUncoreCounterStates</a> (<a class="el" href="classSystemCounterState.html">SystemCounterState</a> &amp;systemState, std::vector&lt; <a class="el" href="classSocketCounterState.html">SocketCounterState</a> &gt; &amp;socketStates)</td></tr>
<tr class="memdesc:a9f1ffc2220b041f739a672b5be82361f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads uncore counter states (including system and sockets) but no core counters.  <a href="#a9f1ffc2220b041f739a672b5be82361f">More...</a><br /></td></tr>
<tr class="separator:a9f1ffc2220b041f739a672b5be82361f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb7e0514fd741966fec461ccd9427f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#aabb7e0514fd741966fec461ccd9427f3">isCoreOnline</a> (int32 os_core_id) const</td></tr>
<tr class="memdesc:aabb7e0514fd741966fec461ccd9427f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the core in online.  <a href="#aabb7e0514fd741966fec461ccd9427f3">More...</a><br /></td></tr>
<tr class="separator:aabb7e0514fd741966fec461ccd9427f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f21fcae47cfb6153055bf922c8a981"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a67f21fcae47cfb6153055bf922c8a981">isSocketOnline</a> (int32 socket_id) const</td></tr>
<tr class="memdesc:a67f21fcae47cfb6153055bf922c8a981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the socket in online.  <a href="#a67f21fcae47cfb6153055bf922c8a981">More...</a><br /></td></tr>
<tr class="separator:a67f21fcae47cfb6153055bf922c8a981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603bf92fb67f294f5bc59185bc5c89cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSystemCounterState.html">SystemCounterState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a603bf92fb67f294f5bc59185bc5c89cb">getSystemCounterState</a> ()</td></tr>
<tr class="memdesc:a603bf92fb67f294f5bc59185bc5c89cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the counter state of the system.  <a href="#a603bf92fb67f294f5bc59185bc5c89cb">More...</a><br /></td></tr>
<tr class="separator:a603bf92fb67f294f5bc59185bc5c89cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade00dbbd2a71ec32ae6747bfca66cd3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSocketCounterState.html">SocketCounterState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ade00dbbd2a71ec32ae6747bfca66cd3c">getSocketCounterState</a> (uint32 socket)</td></tr>
<tr class="memdesc:ade00dbbd2a71ec32ae6747bfca66cd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the counter state of a socket.  <a href="#ade00dbbd2a71ec32ae6747bfca66cd3c">More...</a><br /></td></tr>
<tr class="separator:ade00dbbd2a71ec32ae6747bfca66cd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed1c64e3cb00c76851e3373a1fa54a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCoreCounterState.html">CoreCounterState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a4ed1c64e3cb00c76851e3373a1fa54a3">getCoreCounterState</a> (uint32 core)</td></tr>
<tr class="memdesc:a4ed1c64e3cb00c76851e3373a1fa54a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the counter state of a (logical) core.  <a href="#a4ed1c64e3cb00c76851e3373a1fa54a3">More...</a><br /></td></tr>
<tr class="separator:a4ed1c64e3cb00c76851e3373a1fa54a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d1666c08f014378cf49c707fc978d1"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a18d1666c08f014378cf49c707fc978d1">getNumCores</a> () const</td></tr>
<tr class="memdesc:a18d1666c08f014378cf49c707fc978d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads number of logical cores in the system.  <a href="#a18d1666c08f014378cf49c707fc978d1">More...</a><br /></td></tr>
<tr class="separator:a18d1666c08f014378cf49c707fc978d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30210eb2ddc9eee6bfe1db4b159f922b"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a30210eb2ddc9eee6bfe1db4b159f922b">getNumOnlineCores</a> () const</td></tr>
<tr class="memdesc:a30210eb2ddc9eee6bfe1db4b159f922b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads number of online logical cores in the system.  <a href="#a30210eb2ddc9eee6bfe1db4b159f922b">More...</a><br /></td></tr>
<tr class="separator:a30210eb2ddc9eee6bfe1db4b159f922b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4964e57e7692b5cc67d8b5056e5299"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a7d4964e57e7692b5cc67d8b5056e5299">getNumSockets</a> () const</td></tr>
<tr class="memdesc:a7d4964e57e7692b5cc67d8b5056e5299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads number of sockets (CPUs) in the system.  <a href="#a7d4964e57e7692b5cc67d8b5056e5299">More...</a><br /></td></tr>
<tr class="separator:a7d4964e57e7692b5cc67d8b5056e5299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3c25455743ff4475b237d7c338d4a2"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a9b3c25455743ff4475b237d7c338d4a2">getNumOnlineSockets</a> () const</td></tr>
<tr class="memdesc:a9b3c25455743ff4475b237d7c338d4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads number of online sockets (CPUs) in the system.  <a href="#a9b3c25455743ff4475b237d7c338d4a2">More...</a><br /></td></tr>
<tr class="separator:a9b3c25455743ff4475b237d7c338d4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850a9aeee162133adbc4b5d8df679639"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a850a9aeee162133adbc4b5d8df679639">getThreadsPerCore</a> () const</td></tr>
<tr class="memdesc:a850a9aeee162133adbc4b5d8df679639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads how many hardware threads has a physical core "Hardware thread" is a logical core in a different terminology. If Intel(r) Hyperthreading(tm) is enabled then this function returns 2.  <a href="#a850a9aeee162133adbc4b5d8df679639">More...</a><br /></td></tr>
<tr class="separator:a850a9aeee162133adbc4b5d8df679639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27548ccdca19f180dcc8acd2ca484669"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a27548ccdca19f180dcc8acd2ca484669">getSMT</a> () const</td></tr>
<tr class="memdesc:a27548ccdca19f180dcc8acd2ca484669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if SMT (HyperThreading) is enabled.  <a href="#a27548ccdca19f180dcc8acd2ca484669">More...</a><br /></td></tr>
<tr class="separator:a27548ccdca19f180dcc8acd2ca484669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cd795814da47148632b24e485e6075"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a83cd795814da47148632b24e485e6075">getNominalFrequency</a> () const</td></tr>
<tr class="memdesc:a83cd795814da47148632b24e485e6075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the nominal core frequency.  <a href="#a83cd795814da47148632b24e485e6075">More...</a><br /></td></tr>
<tr class="separator:a83cd795814da47148632b24e485e6075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdc063d0b3fdf7c6b81ef4e5b4c341e"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a2cdc063d0b3fdf7c6b81ef4e5b4c341e">getL3ScalingFactor</a> () const</td></tr>
<tr class="memdesc:a2cdc063d0b3fdf7c6b81ef4e5b4c341e"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs CPUID.0xF.0x01 to get the L3 up scaling factor to calculate L3 Occupancy Scaling factor is returned in EBX register after running the CPU instruction  <a href="#a2cdc063d0b3fdf7c6b81ef4e5b4c341e">More...</a><br /></td></tr>
<tr class="separator:a2cdc063d0b3fdf7c6b81ef4e5b4c341e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab16be3893549f5f2d782071aeaead5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#aab16be3893549f5f2d782071aeaead5f">isSomeCoreOfflined</a> ()</td></tr>
<tr class="memdesc:aab16be3893549f5f2d782071aeaead5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs CPUID.0xB.0x01 to get maximum logical cores (including SMT) per socket. max_lcores_per_socket is returned in EBX[15:0]. Compare this value with number of cores per socket detected in the system to see if some cores are offlined  <a href="#aab16be3893549f5f2d782071aeaead5f">More...</a><br /></td></tr>
<tr class="separator:aab16be3893549f5f2d782071aeaead5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945943a093784e959f2b5930aac85080"><td class="memItemLeft" align="right" valign="top"><a id="a945943a093784e959f2b5930aac85080"></a>
int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a945943a093784e959f2b5930aac85080">getMaxCustomCoreEvents</a> ()</td></tr>
<tr class="memdesc:a945943a093784e959f2b5930aac85080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of custom (general-purpose) core events supported by CPU. <br /></td></tr>
<tr class="separator:a945943a093784e959f2b5930aac85080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8c7d4c978238706fe74ec00c803f9a"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a5f8c7d4c978238706fe74ec00c803f9a">getCPUModel</a> () const</td></tr>
<tr class="memdesc:a5f8c7d4c978238706fe74ec00c803f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads CPU model id.  <a href="#a5f8c7d4c978238706fe74ec00c803f9a">More...</a><br /></td></tr>
<tr class="separator:a5f8c7d4c978238706fe74ec00c803f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf71f98767227aa64821a715bfab099"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#afcf71f98767227aa64821a715bfab099">getCPUStepping</a> () const</td></tr>
<tr class="memdesc:afcf71f98767227aa64821a715bfab099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads CPU stepping id.  <a href="#afcf71f98767227aa64821a715bfab099">More...</a><br /></td></tr>
<tr class="separator:afcf71f98767227aa64821a715bfab099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728347cf85816c42833a1a8a1f14b861"><td class="memItemLeft" align="right" valign="top">int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a728347cf85816c42833a1a8a1f14b861">getThreadId</a> (uint32 os_id) const</td></tr>
<tr class="memdesc:a728347cf85816c42833a1a8a1f14b861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines physical thread of given processor ID within a core.  <a href="#a728347cf85816c42833a1a8a1f14b861">More...</a><br /></td></tr>
<tr class="separator:a728347cf85816c42833a1a8a1f14b861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90eb072bebf4be22bce23d550983f6fe"><td class="memItemLeft" align="right" valign="top">int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a90eb072bebf4be22bce23d550983f6fe">getCoreId</a> (uint32 os_id) const</td></tr>
<tr class="memdesc:a90eb072bebf4be22bce23d550983f6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines physical core of given processor ID within a socket.  <a href="#a90eb072bebf4be22bce23d550983f6fe">More...</a><br /></td></tr>
<tr class="separator:a90eb072bebf4be22bce23d550983f6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4433865e00da98c4fa588cb1be913c"><td class="memItemLeft" align="right" valign="top">int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a2b4433865e00da98c4fa588cb1be913c">getTileId</a> (uint32 os_id) const</td></tr>
<tr class="memdesc:a2b4433865e00da98c4fa588cb1be913c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines physical tile (cores sharing L2 cache) of given processor ID.  <a href="#a2b4433865e00da98c4fa588cb1be913c">More...</a><br /></td></tr>
<tr class="separator:a2b4433865e00da98c4fa588cb1be913c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015a39143b7bb87b41dc34b43a926029"><td class="memItemLeft" align="right" valign="top">int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a015a39143b7bb87b41dc34b43a926029">getSocketId</a> (uint32 core_id) const</td></tr>
<tr class="memdesc:a015a39143b7bb87b41dc34b43a926029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines socket of given core.  <a href="#a015a39143b7bb87b41dc34b43a926029">More...</a><br /></td></tr>
<tr class="separator:a015a39143b7bb87b41dc34b43a926029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f62775b214218edf64a3f68df6c932"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#af0f62775b214218edf64a3f68df6c932">getQPILinksPerSocket</a> () const</td></tr>
<tr class="memdesc:af0f62775b214218edf64a3f68df6c932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of Intel(r) Quick Path Interconnect(tm) links per socket.  <a href="#af0f62775b214218edf64a3f68df6c932">More...</a><br /></td></tr>
<tr class="separator:af0f62775b214218edf64a3f68df6c932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47f2de0de9403d00a4dac72919c8c38"><td class="memItemLeft" align="right" valign="top"><a id="af47f2de0de9403d00a4dac72919c8c38"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#af47f2de0de9403d00a4dac72919c8c38">getMCPerSocket</a> () const</td></tr>
<tr class="memdesc:af47f2de0de9403d00a4dac72919c8c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of detected integrated memory controllers per socket. <br /></td></tr>
<tr class="separator:af47f2de0de9403d00a4dac72919c8c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8509261ccf013554e4ca31f66edf65af"><td class="memItemLeft" align="right" valign="top"><a id="a8509261ccf013554e4ca31f66edf65af"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a8509261ccf013554e4ca31f66edf65af">getMCChannelsPerSocket</a> () const</td></tr>
<tr class="memdesc:a8509261ccf013554e4ca31f66edf65af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of detected memory channels on all integrated memory controllers per socket. <br /></td></tr>
<tr class="separator:a8509261ccf013554e4ca31f66edf65af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ec2128018c26d8c6dc70a41dae2080"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#aa6ec2128018c26d8c6dc70a41dae2080">getMCChannels</a> (uint32 socket, uint32 controller) const</td></tr>
<tr class="memdesc:aa6ec2128018c26d8c6dc70a41dae2080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of detected memory channels on given integrated memory controllers.  <a href="#aa6ec2128018c26d8c6dc70a41dae2080">More...</a><br /></td></tr>
<tr class="separator:aa6ec2128018c26d8c6dc70a41dae2080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b8f36a804566a381cba176107ded6d"><td class="memItemLeft" align="right" valign="top"><a id="a51b8f36a804566a381cba176107ded6d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a51b8f36a804566a381cba176107ded6d">getEDCChannelsPerSocket</a> () const</td></tr>
<tr class="memdesc:a51b8f36a804566a381cba176107ded6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of detected memory channels on all integrated memory controllers per socket. <br /></td></tr>
<tr class="separator:a51b8f36a804566a381cba176107ded6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17084236c1d744a92adec4205415e0ad"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a17084236c1d744a92adec4205415e0ad">getMaxIPC</a> () const</td></tr>
<tr class="memdesc:a17084236c1d744a92adec4205415e0ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the max number of instructions per cycle.  <a href="#a17084236c1d744a92adec4205415e0ad">More...</a><br /></td></tr>
<tr class="separator:a17084236c1d744a92adec4205415e0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9911d0d2edf17ecffd24ffce5a31a982"><td class="memItemLeft" align="right" valign="top"><a id="a9911d0d2edf17ecffd24ffce5a31a982"></a>
uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a9911d0d2edf17ecffd24ffce5a31a982">getPCUFrequency</a> () const</td></tr>
<tr class="memdesc:a9911d0d2edf17ecffd24ffce5a31a982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the frequency of Power Control Unit. <br /></td></tr>
<tr class="separator:a9911d0d2edf17ecffd24ffce5a31a982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491397535c61bdc2ed5c3e8c9e229d2d"><td class="memItemLeft" align="right" valign="top"><a id="a491397535c61bdc2ed5c3e8c9e229d2d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a491397535c61bdc2ed5c3e8c9e229d2d">isServerCPU</a> () const</td></tr>
<tr class="memdesc:a491397535c61bdc2ed5c3e8c9e229d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether it is a server part. <br /></td></tr>
<tr class="separator:a491397535c61bdc2ed5c3e8c9e229d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b53ec23752cb1fe3dc7e166abbe13e"><td class="memItemLeft" align="right" valign="top"><a id="a33b53ec23752cb1fe3dc7e166abbe13e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a33b53ec23752cb1fe3dc7e166abbe13e">isClientCPU</a> () const</td></tr>
<tr class="memdesc:a33b53ec23752cb1fe3dc7e166abbe13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether it is a client part. <br /></td></tr>
<tr class="separator:a33b53ec23752cb1fe3dc7e166abbe13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794f5852662a2827b34eb16025564c70"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a794f5852662a2827b34eb16025564c70">getTickCount</a> (uint64 multiplier=1000, uint32 core=0)</td></tr>
<tr class="memdesc:a794f5852662a2827b34eb16025564c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TSC timer value in time units.  <a href="#a794f5852662a2827b34eb16025564c70">More...</a><br /></td></tr>
<tr class="separator:a794f5852662a2827b34eb16025564c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5153c7ec05003da7d20aeea737113e"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a0d5153c7ec05003da7d20aeea737113e">getTickCountRDTSCP</a> (uint64 multiplier=1000)</td></tr>
<tr class="memdesc:a0d5153c7ec05003da7d20aeea737113e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TSC timer value in time units using rdtscp instruction from current core.  <a href="#a0d5153c7ec05003da7d20aeea737113e">More...</a><br /></td></tr>
<tr class="separator:a0d5153c7ec05003da7d20aeea737113e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ea813c4cd70d3f7fe73cf1e0aca706"><td class="memItemLeft" align="right" valign="top"><a id="a09ea813c4cd70d3f7fe73cf1e0aca706"></a>
uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a09ea813c4cd70d3f7fe73cf1e0aca706">getUncoreClocks</a> (const uint32 socket_)</td></tr>
<tr class="memdesc:a09ea813c4cd70d3f7fe73cf1e0aca706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns uncore clock ticks on specified socket. <br /></td></tr>
<tr class="separator:a09ea813c4cd70d3f7fe73cf1e0aca706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfa5b2f12f2e98382f9d8ddbc0c02e1"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a9bfa5b2f12f2e98382f9d8ddbc0c02e1">getQPILinkSpeed</a> (uint32 socketNr, uint32 linkNr) const</td></tr>
<tr class="memdesc:a9bfa5b2f12f2e98382f9d8ddbc0c02e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return QPI Link Speed in GBytes/second.  <a href="#a9bfa5b2f12f2e98382f9d8ddbc0c02e1">More...</a><br /></td></tr>
<tr class="separator:a9bfa5b2f12f2e98382f9d8ddbc0c02e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae933960b6244fe1d96ec4306a61c0e3a"><td class="memItemLeft" align="right" valign="top"><a id="ae933960b6244fe1d96ec4306a61c0e3a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ae933960b6244fe1d96ec4306a61c0e3a">getJoulesPerEnergyUnit</a> () const</td></tr>
<tr class="memdesc:ae933960b6244fe1d96ec4306a61c0e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many joules are in an internal processor energy unit. <br /></td></tr>
<tr class="separator:ae933960b6244fe1d96ec4306a61c0e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd024b683196cfbd6106252c47c3337"><td class="memItemLeft" align="right" valign="top"><a id="a2dd024b683196cfbd6106252c47c3337"></a>
int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a2dd024b683196cfbd6106252c47c3337">getPackageThermalSpecPower</a> () const</td></tr>
<tr class="memdesc:a2dd024b683196cfbd6106252c47c3337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns thermal specification power of the package domain in Watt. <br /></td></tr>
<tr class="separator:a2dd024b683196cfbd6106252c47c3337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3038bc44fb2fdd31e072b8cc8cf4b09"><td class="memItemLeft" align="right" valign="top"><a id="ad3038bc44fb2fdd31e072b8cc8cf4b09"></a>
int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ad3038bc44fb2fdd31e072b8cc8cf4b09">getPackageMinimumPower</a> () const</td></tr>
<tr class="memdesc:ad3038bc44fb2fdd31e072b8cc8cf4b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns minimum power derived from electrical spec of the package domain in Watt. <br /></td></tr>
<tr class="separator:ad3038bc44fb2fdd31e072b8cc8cf4b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b39ec58f622cd07c07fdf03ae4f543"><td class="memItemLeft" align="right" valign="top"><a id="a51b39ec58f622cd07c07fdf03ae4f543"></a>
int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a51b39ec58f622cd07c07fdf03ae4f543">getPackageMaximumPower</a> () const</td></tr>
<tr class="memdesc:a51b39ec58f622cd07c07fdf03ae4f543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns maximum power derived from electrical spec of the package domain in Watt. <br /></td></tr>
<tr class="separator:a51b39ec58f622cd07c07fdf03ae4f543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb695430e52dcf00adab2aa270f0cb11"><td class="memItemLeft" align="right" valign="top"><a id="abb695430e52dcf00adab2aa270f0cb11"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>disableJKTWorkaround</b> ()</td></tr>
<tr class="separator:abb695430e52dcf00adab2aa270f0cb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ac3b31cd69a97c45078b40baa44556"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a98ac3b31cd69a97c45078b40baa44556">programPCIeEventGroup</a> (eventGroup_t &amp;eventGroup)</td></tr>
<tr class="memdesc:a98ac3b31cd69a97c45078b40baa44556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program uncore PCIe monitoring event(s)  <a href="#a98ac3b31cd69a97c45078b40baa44556">More...</a><br /></td></tr>
<tr class="separator:a98ac3b31cd69a97c45078b40baa44556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da4b438ec698f03a643693bc876dd4d"><td class="memItemLeft" align="right" valign="top"><a id="a0da4b438ec698f03a643693bc876dd4d"></a>
uint64&#160;</td><td class="memItemRight" valign="bottom"><b>getPCIeCounterData</b> (const uint32 socket_, const uint32 ctr_)</td></tr>
<tr class="separator:a0da4b438ec698f03a643693bc876dd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bc59f9d7cfc87fbd4ee88aaeb6e846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#aa7bc59f9d7cfc87fbd4ee88aaeb6e846">programCbo</a> (const uint64 *events, const uint32 opCode, const uint32 nc_=0, const uint32 llc_lookup_tid_filter=0, const uint32 loc=1, const uint32 rem=1)</td></tr>
<tr class="memdesc:aa7bc59f9d7cfc87fbd4ee88aaeb6e846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program CBO (or CHA on SKX+) counters.  <a href="#aa7bc59f9d7cfc87fbd4ee88aaeb6e846">More...</a><br /></td></tr>
<tr class="separator:aa7bc59f9d7cfc87fbd4ee88aaeb6e846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1b549672af4c14c00eb7d461c87ac4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimpleCounterState.html">PCIeCounterState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a3b1b549672af4c14c00eb7d461c87ac4">getPCIeCounterState</a> (const uint32 socket_)</td></tr>
<tr class="memdesc:a3b1b549672af4c14c00eb7d461c87ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the state of PCIe <a class="el" href="structcounter.html">counter(s)</a>  <a href="#a3b1b549672af4c14c00eb7d461c87ac4">More...</a><br /></td></tr>
<tr class="separator:a3b1b549672af4c14c00eb7d461c87ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75fcae283d8c6f0ef7085a913685f0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ac75fcae283d8c6f0ef7085a913685f0b">programIIOCounters</a> (<a class="el" href="structIIOPMUCNTCTLRegister.html">IIOPMUCNTCTLRegister</a> rawEvents[4], int IIOStack=-1)</td></tr>
<tr class="memdesc:ac75fcae283d8c6f0ef7085a913685f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program uncore IIO events.  <a href="#ac75fcae283d8c6f0ef7085a913685f0b">More...</a><br /></td></tr>
<tr class="separator:ac75fcae283d8c6f0ef7085a913685f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e2036c24c34ab5eecce856382d19fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimpleCounterState.html">IIOCounterState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a85e2036c24c34ab5eecce856382d19fb">getIIOCounterState</a> (int socket, int IIOStack, int <a class="el" href="structcounter.html">counter</a>)</td></tr>
<tr class="memdesc:a85e2036c24c34ab5eecce856382d19fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the state of IIO counter.  <a href="#a85e2036c24c34ab5eecce856382d19fb">More...</a><br /></td></tr>
<tr class="separator:a85e2036c24c34ab5eecce856382d19fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e8b223197728858a704d53b8ab5534"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a25e8b223197728858a704d53b8ab5534">getIIOCounterStates</a> (int socket, int IIOStack, <a class="el" href="classSimpleCounterState.html">IIOCounterState</a> *result)</td></tr>
<tr class="memdesc:a25e8b223197728858a704d53b8ab5534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the states of the four IIO counters in bulk (faster than four single reads)  <a href="#a25e8b223197728858a704d53b8ab5534">More...</a><br /></td></tr>
<tr class="separator:a25e8b223197728858a704d53b8ab5534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe37e4fcbf856df75c9fbdd83d9054a1"><td class="memItemLeft" align="right" valign="top"><a id="abe37e4fcbf856df75c9fbdd83d9054a1"></a>
uint64&#160;</td><td class="memItemRight" valign="bottom"><b>extractCoreGenCounterValue</b> (uint64 val)</td></tr>
<tr class="separator:abe37e4fcbf856df75c9fbdd83d9054a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efedba414c4b01207e6d57dc83dd66a"><td class="memItemLeft" align="right" valign="top"><a id="a9efedba414c4b01207e6d57dc83dd66a"></a>
uint64&#160;</td><td class="memItemRight" valign="bottom"><b>extractCoreFixedCounterValue</b> (uint64 val)</td></tr>
<tr class="separator:a9efedba414c4b01207e6d57dc83dd66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad9ccfca970ae03229377926df029cc"><td class="memItemLeft" align="right" valign="top"><a id="abad9ccfca970ae03229377926df029cc"></a>
uint64&#160;</td><td class="memItemRight" valign="bottom"><b>extractUncoreGenCounterValue</b> (uint64 val)</td></tr>
<tr class="separator:abad9ccfca970ae03229377926df029cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea22c144bd0a0a2c2672b49b0ad5a5b"><td class="memItemLeft" align="right" valign="top"><a id="a8ea22c144bd0a0a2c2672b49b0ad5a5b"></a>
uint64&#160;</td><td class="memItemRight" valign="bottom"><b>extractUncoreFixedCounterValue</b> (uint64 val)</td></tr>
<tr class="separator:a8ea22c144bd0a0a2c2672b49b0ad5a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42f103a8df6035c075f022d6c7de04d"><td class="memItemLeft" align="right" valign="top"><a id="ab42f103a8df6035c075f022d6c7de04d"></a>
uint64&#160;</td><td class="memItemRight" valign="bottom"><b>extractQOSMonitoring</b> (uint64 val)</td></tr>
<tr class="separator:ab42f103a8df6035c075f022d6c7de04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d4aa1ea3a38a348e27a98dd5c61fda"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#aa1d4aa1ea3a38a348e27a98dd5c61fda">getUArchCodename</a> (const int32 cpu_model_=-1) const</td></tr>
<tr class="memdesc:aa1d4aa1ea3a38a348e27a98dd5c61fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string describing the codename of the processor microarchitecture.  <a href="#aa1d4aa1ea3a38a348e27a98dd5c61fda">More...</a><br /></td></tr>
<tr class="separator:aa1d4aa1ea3a38a348e27a98dd5c61fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa593d2445c7c96ebcb2e37222c2d8ff4"><td class="memItemLeft" align="right" valign="top"><a id="aa593d2445c7c96ebcb2e37222c2d8ff4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getCPUFamilyModelString</b> ()</td></tr>
<tr class="separator:aa593d2445c7c96ebcb2e37222c2d8ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43e9a34bee35052fc819d00206c9f71"><td class="memItemLeft" align="right" valign="top"><a id="ac43e9a34bee35052fc819d00206c9f71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ac43e9a34bee35052fc819d00206c9f71">enableForceRTMAbortMode</a> ()</td></tr>
<tr class="memdesc:ac43e9a34bee35052fc819d00206c9f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables "force all RTM transaction abort" mode also enabling 4+ programmable counters on Skylake generation processors. <br /></td></tr>
<tr class="separator:ac43e9a34bee35052fc819d00206c9f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282fd9c2760d4738d18a86fa97529487"><td class="memItemLeft" align="right" valign="top"><a id="a282fd9c2760d4738d18a86fa97529487"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a282fd9c2760d4738d18a86fa97529487">isForceRTMAbortModeEnabled</a> () const</td></tr>
<tr class="memdesc:a282fd9c2760d4738d18a86fa97529487"><td class="mdescLeft">&#160;</td><td class="mdescRight">queries status of "force all RTM transaction abort" mode <br /></td></tr>
<tr class="separator:a282fd9c2760d4738d18a86fa97529487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac893dd123900de96757c5844582d48ff"><td class="memItemLeft" align="right" valign="top"><a id="ac893dd123900de96757c5844582d48ff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ac893dd123900de96757c5844582d48ff">disableForceRTMAbortMode</a> ()</td></tr>
<tr class="memdesc:ac893dd123900de96757c5844582d48ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables "force all RTM transaction abort" mode restricting the number of programmable counters on Skylake generation processors to 3. <br /></td></tr>
<tr class="separator:ac893dd123900de96757c5844582d48ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b1f811c83733d1c02d53371f4a2387"><td class="memItemLeft" align="right" valign="top"><a id="a09b1f811c83733d1c02d53371f4a2387"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a09b1f811c83733d1c02d53371f4a2387">isForceRTMAbortModeAvailable</a> () const</td></tr>
<tr class="memdesc:a09b1f811c83733d1c02d53371f4a2387"><td class="mdescLeft">&#160;</td><td class="mdescRight">queries availability of "force all RTM transaction abort" mode <br /></td></tr>
<tr class="separator:a09b1f811c83733d1c02d53371f4a2387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6e4c165db2cfaabaf8f5758a29ae40"><td class="memItemLeft" align="right" valign="top"><a id="a7e6e4c165db2cfaabaf8f5758a29ae40"></a>
int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a7e6e4c165db2cfaabaf8f5758a29ae40">getCPUMicrocodeLevel</a> () const</td></tr>
<tr class="memdesc:a7e6e4c165db2cfaabaf8f5758a29ae40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get microcode level (returns -1 if retrieval not supported due to some restrictions) <br /></td></tr>
<tr class="separator:a7e6e4c165db2cfaabaf8f5758a29ae40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d9a0ddb37cc4f87ac95b544cc36c9b"><td class="memItemLeft" align="right" valign="top"><a id="a28d9a0ddb37cc4f87ac95b544cc36c9b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a28d9a0ddb37cc4f87ac95b544cc36c9b">isAtom</a> () const</td></tr>
<tr class="memdesc:a28d9a0ddb37cc4f87ac95b544cc36c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if CPU is Atom-based <br /></td></tr>
<tr class="separator:a28d9a0ddb37cc4f87ac95b544cc36c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b0f8e35174cd37da0f3b9200faf978"><td class="memItemLeft" align="right" valign="top"><a id="a12b0f8e35174cd37da0f3b9200faf978"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>packageEnergyMetricsAvailable</b> () const</td></tr>
<tr class="separator:a12b0f8e35174cd37da0f3b9200faf978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2202ca6339cf5df064bd94f22036e92a"><td class="memItemLeft" align="right" valign="top"><a id="a2202ca6339cf5df064bd94f22036e92a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>dramEnergyMetricsAvailable</b> () const</td></tr>
<tr class="separator:a2202ca6339cf5df064bd94f22036e92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa584d7a737db19e0ee032eae012d1dd"><td class="memItemLeft" align="right" valign="top"><a id="aaa584d7a737db19e0ee032eae012d1dd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>packageThermalMetricsAvailable</b> () const</td></tr>
<tr class="separator:aaa584d7a737db19e0ee032eae012d1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004d5ea964102d4c3522e1be0b0f28ff"><td class="memItemLeft" align="right" valign="top"><a id="a004d5ea964102d4c3522e1be0b0f28ff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>outgoingQPITrafficMetricsAvailable</b> () const</td></tr>
<tr class="separator:a004d5ea964102d4c3522e1be0b0f28ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822228200e8f6a4f46fd3abb106fae2c"><td class="memItemLeft" align="right" valign="top"><a id="a822228200e8f6a4f46fd3abb106fae2c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>incomingQPITrafficMetricsAvailable</b> () const</td></tr>
<tr class="separator:a822228200e8f6a4f46fd3abb106fae2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bc3e978131a34794c40889ee30dcff"><td class="memItemLeft" align="right" valign="top"><a id="a10bc3e978131a34794c40889ee30dcff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>localMemoryRequestRatioMetricAvailable</b> () const</td></tr>
<tr class="separator:a10bc3e978131a34794c40889ee30dcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913d07e562d0c12276e1d88da68133cf"><td class="memItemLeft" align="right" valign="top"><a id="a913d07e562d0c12276e1d88da68133cf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>qpiUtilizationMetricsAvailable</b> () const</td></tr>
<tr class="separator:a913d07e562d0c12276e1d88da68133cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc270d601a110e0a6667bfbaf2441844"><td class="memItemLeft" align="right" valign="top"><a id="afc270d601a110e0a6667bfbaf2441844"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>memoryTrafficMetricsAvailable</b> () const</td></tr>
<tr class="separator:afc270d601a110e0a6667bfbaf2441844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43b77a3c73011dc885219d1f02301f0"><td class="memItemLeft" align="right" valign="top"><a id="ac43b77a3c73011dc885219d1f02301f0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MCDRAMmemoryTrafficMetricsAvailable</b> () const</td></tr>
<tr class="separator:ac43b77a3c73011dc885219d1f02301f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2821d0a34e459b897b11b2b6a2bc55"><td class="memItemLeft" align="right" valign="top"><a id="adb2821d0a34e459b897b11b2b6a2bc55"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>memoryIOTrafficMetricAvailable</b> () const</td></tr>
<tr class="separator:adb2821d0a34e459b897b11b2b6a2bc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0ec9f5d7d476e15de4b292a8d09227"><td class="memItemLeft" align="right" valign="top"><a id="adb0ec9f5d7d476e15de4b292a8d09227"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IIOEventsAvailable</b> () const</td></tr>
<tr class="separator:adb0ec9f5d7d476e15de4b292a8d09227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb7f7576ab00f86ad73a8c1129a3ad6"><td class="memItemLeft" align="right" valign="top"><a id="afdb7f7576ab00f86ad73a8c1129a3ad6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>LatencyMetricsAvailable</b> () const</td></tr>
<tr class="separator:afdb7f7576ab00f86ad73a8c1129a3ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a77ba7da0298ca3fb3df9205ac85206"><td class="memItemLeft" align="right" valign="top"><a id="a8a77ba7da0298ca3fb3df9205ac85206"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>DDRLatencyMetricsAvailable</b> () const</td></tr>
<tr class="separator:a8a77ba7da0298ca3fb3df9205ac85206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8a40004d765526aa973df8f4f013ea"><td class="memItemLeft" align="right" valign="top"><a id="a3f8a40004d765526aa973df8f4f013ea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>PMMTrafficMetricsAvailable</b> () const</td></tr>
<tr class="separator:a3f8a40004d765526aa973df8f4f013ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea9a88fefc7deb2374698498b26a623"><td class="memItemLeft" align="right" valign="top"><a id="afea9a88fefc7deb2374698498b26a623"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>LLCReadMissLatencyMetricsAvailable</b> () const</td></tr>
<tr class="separator:afea9a88fefc7deb2374698498b26a623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f46c4337260f8bd2a0239fa34d58ca7"><td class="memItemLeft" align="right" valign="top"><a id="a9f46c4337260f8bd2a0239fa34d58ca7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasBecktonUncore</b> () const</td></tr>
<tr class="separator:a9f46c4337260f8bd2a0239fa34d58ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeaa5778a26d62b6b55a1696a2189ff1"><td class="memItemLeft" align="right" valign="top"><a id="abeaa5778a26d62b6b55a1696a2189ff1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasPCICFGUncore</b> () const</td></tr>
<tr class="separator:abeaa5778a26d62b6b55a1696a2189ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095e8cdf895b725ff6480a1933245bd9"><td class="memItemLeft" align="right" valign="top"><a id="a095e8cdf895b725ff6480a1933245bd9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSkxCompatible</b> () const</td></tr>
<tr class="separator:a095e8cdf895b725ff6480a1933245bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757dea905954dc838707260c58d86e5f"><td class="memItemLeft" align="right" valign="top"><a id="a757dea905954dc838707260c58d86e5f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasUPI</b> () const</td></tr>
<tr class="separator:a757dea905954dc838707260c58d86e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accac637ae1f85101df7a04883f09b2da"><td class="memItemLeft" align="right" valign="top"><a id="accac637ae1f85101df7a04883f09b2da"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>xPI</b> () const</td></tr>
<tr class="separator:accac637ae1f85101df7a04883f09b2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd427b8a89cd51485a1668eec9a3c886"><td class="memItemLeft" align="right" valign="top"><a id="abd427b8a89cd51485a1668eec9a3c886"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasCHA</b> () const</td></tr>
<tr class="separator:abd427b8a89cd51485a1668eec9a3c886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd40f38d7808f0500c89fd0fee37d7f"><td class="memItemLeft" align="right" valign="top"><a id="a3fd40f38d7808f0500c89fd0fee37d7f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>supportsHLE</b> () const</td></tr>
<tr class="separator:a3fd40f38d7808f0500c89fd0fee37d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af716484d0216f34fc2012aa9287dd48f"><td class="memItemLeft" align="right" valign="top"><a id="af716484d0216f34fc2012aa9287dd48f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>supportsRTM</b> () const</td></tr>
<tr class="separator:af716484d0216f34fc2012aa9287dd48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5aaa92b67a86c6e31e42a7ff072132"><td class="memItemLeft" align="right" valign="top"><a id="a7f5aaa92b67a86c6e31e42a7ff072132"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>useSkylakeEvents</b> () const</td></tr>
<tr class="separator:a7f5aaa92b67a86c6e31e42a7ff072132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c442047ee84f0807ab61b81f9a7f1a"><td class="memItemLeft" align="right" valign="top"><a id="a27c442047ee84f0807ab61b81f9a7f1a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getBytesPerFlit</b> () const</td></tr>
<tr class="separator:a27c442047ee84f0807ab61b81f9a7f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579b94eed3d9bfa6a707bee9be0edf86"><td class="memItemLeft" align="right" valign="top"><a id="a579b94eed3d9bfa6a707bee9be0edf86"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getDataBytesPerFlit</b> () const</td></tr>
<tr class="separator:a579b94eed3d9bfa6a707bee9be0edf86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d9964b35c963041e923523bebbefdd"><td class="memItemLeft" align="right" valign="top"><a id="a03d9964b35c963041e923523bebbefdd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getBytesPerLinkCycle</b> () const</td></tr>
<tr class="separator:a03d9964b35c963041e923523bebbefdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af809894fbc9dda902300016cd4f4ad7b"><td class="memItemLeft" align="right" valign="top"><a id="af809894fbc9dda902300016cd4f4ad7b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getBytesPerLinkTransfer</b> () const</td></tr>
<tr class="separator:af809894fbc9dda902300016cd4f4ad7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6624cfd942b9727136dc59a2c7df87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#aab6624cfd942b9727136dc59a2c7df87">setupCustomCoreEventsForNuma</a> (<a class="el" href="structPCM_1_1ExtendedCustomCoreEventDescription.html">PCM::ExtendedCustomCoreEventDescription</a> &amp;conf) const</td></tr>
<tr class="memdesc:aab6624cfd942b9727136dc59a2c7df87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup <a class="el" href="structPCM_1_1ExtendedCustomCoreEventDescription.html" title="Extended custom core event description. ">ExtendedCustomCoreEventDescription</a> object to read offcore (numa) counters for each processor type.  <a href="#aab6624cfd942b9727136dc59a2c7df87">More...</a><br /></td></tr>
<tr class="separator:aab6624cfd942b9727136dc59a2c7df87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac3cbbdbd98d823fce47c5f5da50a3d"><td class="memItemLeft" align="right" valign="top"><a id="a8ac3cbbdbd98d823fce47c5f5da50a3d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isActiveRelativeFrequencyAvailable</b> () const</td></tr>
<tr class="separator:a8ac3cbbdbd98d823fce47c5f5da50a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a155611028fb95409625e44784f7b4c7b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classPCM.html">PCM</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a155611028fb95409625e44784f7b4c7b">getInstance</a> ()</td></tr>
<tr class="memdesc:a155611028fb95409625e44784f7b4c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> object.  <a href="#a155611028fb95409625e44784f7b4c7b">More...</a><br /></td></tr>
<tr class="separator:a155611028fb95409625e44784f7b4c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4cabfe4223f1d2e7e1e0da8b1179b3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a5e4cabfe4223f1d2e7e1e0da8b1179b3">initWinRing0Lib</a> ()</td></tr>
<tr class="memdesc:a5e4cabfe4223f1d2e7e1e0da8b1179b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads and initializes Winring0 third party library for access to processor model specific and PCI configuration registers.  <a href="#a5e4cabfe4223f1d2e7e1e0da8b1179b3">More...</a><br /></td></tr>
<tr class="separator:a5e4cabfe4223f1d2e7e1e0da8b1179b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3279d88bbd5c2eab06c9c6cb6248c3c7"><td class="memItemLeft" align="right" valign="top"><a id="a3279d88bbd5c2eab06c9c6cb6248c3c7"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a3279d88bbd5c2eab06c9c6cb6248c3c7">getCPUBrandString</a> ()</td></tr>
<tr class="memdesc:a3279d88bbd5c2eab06c9c6cb6248c3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Brand string of processor. <br /></td></tr>
<tr class="separator:a3279d88bbd5c2eab06c9c6cb6248c3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff51f06eed09faa5c86a616a9466925"><td class="memItemLeft" align="right" valign="top"><a id="a1ff51f06eed09faa5c86a616a9466925"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a1ff51f06eed09faa5c86a616a9466925">isAtom</a> (const int32 cpu_model_)</td></tr>
<tr class="memdesc:a1ff51f06eed09faa5c86a616a9466925"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if CPU model is Atom-based <br /></td></tr>
<tr class="separator:a1ff51f06eed09faa5c86a616a9466925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe68963c6367e5cf69d7800b4ab4f16"><td class="memItemLeft" align="right" valign="top"><a id="aafe68963c6367e5cf69d7800b4ab4f16"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>getBytesPerFlit</b> (int32 cpu_model_)</td></tr>
<tr class="separator:aafe68963c6367e5cf69d7800b4ab4f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18864560cbdfe1b91d6a0157f34503df"><td class="memItemLeft" align="right" valign="top"><a id="a18864560cbdfe1b91d6a0157f34503df"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>getDataBytesPerFlit</b> (int32 cpu_model_)</td></tr>
<tr class="separator:a18864560cbdfe1b91d6a0157f34503df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac403b42e61409ce5f0f630b41c5e2a32"><td class="memItemLeft" align="right" valign="top"><a id="ac403b42e61409ce5f0f630b41c5e2a32"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>getFlitsPerLinkCycle</b> (int32 cpu_model_)</td></tr>
<tr class="separator:ac403b42e61409ce5f0f630b41c5e2a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4130371367f0ab31b05828ee0c02a0"><td class="memItemLeft" align="right" valign="top"><a id="a6b4130371367f0ab31b05828ee0c02a0"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>getBytesPerLinkCycle</b> (int32 cpu_model_)</td></tr>
<tr class="separator:a6b4130371367f0ab31b05828ee0c02a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746b80c6942509dec884cbaabf663a74"><td class="memItemLeft" align="right" valign="top"><a id="a746b80c6942509dec884cbaabf663a74"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>getLinkTransfersPerLinkCycle</b> ()</td></tr>
<tr class="separator:a746b80c6942509dec884cbaabf663a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae338fe587ce44ca6801b2f280dd87b25"><td class="memItemLeft" align="right" valign="top"><a id="ae338fe587ce44ca6801b2f280dd87b25"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>BasicCounterState</b></td></tr>
<tr class="separator:ae338fe587ce44ca6801b2f280dd87b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a2644b6d84c756de9746c1cf1ed68e"><td class="memItemLeft" align="right" valign="top"><a id="a50a2644b6d84c756de9746c1cf1ed68e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>UncoreCounterState</b></td></tr>
<tr class="separator:a50a2644b6d84c756de9746c1cf1ed68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab510887d735ee73ab1cb598c66260e87"><td class="memItemLeft" align="right" valign="top"><a id="ab510887d735ee73ab1cb598c66260e87"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Socket</b></td></tr>
<tr class="separator:ab510887d735ee73ab1cb598c66260e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548f3d0a85071d74471b9f734969f2aa"><td class="memItemLeft" align="right" valign="top"><a id="a548f3d0a85071d74471b9f734969f2aa"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ServerUncore</b></td></tr>
<tr class="separator:a548f3d0a85071d74471b9f734969f2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529129afa60fae863af10b2a549e51d6"><td class="memItemLeft" align="right" valign="top"><a id="a529129afa60fae863af10b2a549e51d6"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PerfVirtualControlRegister</b></td></tr>
<tr class="separator:a529129afa60fae863af10b2a549e51d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c863bd15229565be61ed7cb1406b5b"><td class="memItemLeft" align="right" valign="top"><a id="af6c863bd15229565be61ed7cb1406b5b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Aggregator</b></td></tr>
<tr class="separator:af6c863bd15229565be61ed7cb1406b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab646c3f347733e4363c1d98f4036ef84"><td class="memItemLeft" align="right" valign="top"><a id="ab646c3f347733e4363c1d98f4036ef84"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ServerPCICFGUncore</b></td></tr>
<tr class="separator:ab646c3f347733e4363c1d98f4036ef84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>CPU Performance Monitor. </p>
<p>This singleton object needs to be instantiated for each process before accessing counting and measuring routines </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a88584813a3ef51376efeb22928764786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88584813a3ef51376efeb22928764786">&#9670;&nbsp;</a></span>ProgramMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786">PCM::ProgramMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mode of programming (parameter in the <a class="el" href="classPCM.html#abae9577a1a172c944d133bef10683825" title="Programs performance counters. ">program()</a> method) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a88584813a3ef51376efeb22928764786a0e861144f482697cfa423b012ed42451"></a>DEFAULT_EVENTS&#160;</td><td class="fielddoc"><p>Default choice of events, the additional parameter is not needed and ignored </p>
</td></tr>
<tr><td class="fieldname"><a id="a88584813a3ef51376efeb22928764786ac092b2b5f351e33046b87e5cee31f38f"></a>CUSTOM_CORE_EVENTS&#160;</td><td class="fielddoc"><p>Custom set of core events specified in the parameter to the program method. The parameter must be a pointer to array of four <code><a class="el" href="structPCM_1_1CustomCoreEventDescription.html" title="Custom Core event description. ">CustomCoreEventDescription</a></code> values </p>
</td></tr>
<tr><td class="fieldname"><a id="a88584813a3ef51376efeb22928764786a0f2ff80b85b8f9483c7f03544f73fcbd"></a>EXT_CUSTOM_CORE_EVENTS&#160;</td><td class="fielddoc"><p>Custom set of core events specified in the parameter to the program method. The parameter must be a pointer to a <code><a class="el" href="structPCM_1_1ExtendedCustomCoreEventDescription.html" title="Extended custom core event description. ">ExtendedCustomCoreEventDescription</a></code> data structure </p>
</td></tr>
<tr><td class="fieldname"><a id="a88584813a3ef51376efeb22928764786ad60e2f3b64e27eaaa84d2b07fea8e225"></a>INVALID_MODE&#160;</td><td class="fielddoc"><p>Non-programmed mode </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac0c8d3764ff95840ece17d632de4df9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c8d3764ff95840ece17d632de4df9b">&#9670;&nbsp;</a></span>cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM::cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleanups resources and stops performance counting. </p>
<p>One needs to call this method when your program finishes or/and you are not going to use the performance counting routines anymore. </p>

<p class="reference">References <a class="el" href="classPCM.html#ac893dd123900de96757c5844582d48ff">disableForceRTMAbortMode()</a>.</p>

<p class="reference">Referenced by <a class="el" href="utils_8h.html#ad7f085309ae89de98d2f3755d6b00d6a">exit_cleanup()</a>.</p>

</div>
</div>
<a id="af0648834f063a6bd2ea88c61a2ba286d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0648834f063a6bd2ea88c61a2ba286d">&#9670;&nbsp;</a></span>CoreLocalMemoryBWMetricAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM::CoreLocalMemoryBWMetricAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if local memory bandwidth monitoring present </p>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

<p class="reference">References <a class="el" href="classPCM.html#ab1be879d2c871816ddbcfa30bb58a3e7">L3QOSMetricAvailable()</a>, and <a class="el" href="classPCM.html#ad12300d8a7096cc4258108ced23cd491">QOSMetricAvailable()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cpucounters_8h.html#a3ba7c9267c6e0f338a59defc98ae0007">getLocalMemoryBW()</a>.</p>

</div>
</div>
<a id="a9b2b73d2af7c5a851e5c43df37d7fdb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2b73d2af7c5a851e5c43df37d7fdb2">&#9670;&nbsp;</a></span>CoreRemoteMemoryBWMetricAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM::CoreRemoteMemoryBWMetricAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if total memory bandwidth monitoring present </p>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

<p class="reference">References <a class="el" href="classPCM.html#ab1be879d2c871816ddbcfa30bb58a3e7">L3QOSMetricAvailable()</a>, and <a class="el" href="classPCM.html#ad12300d8a7096cc4258108ced23cd491">QOSMetricAvailable()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cpucounters_8h.html#a00c97b1a7d8a7125ce7fd129cddb52e8">getRemoteMemoryBW()</a>.</p>

</div>
</div>
<a id="ade92d30321a659ca54d423eaf0e30e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade92d30321a659ca54d423eaf0e30e12">&#9670;&nbsp;</a></span>getAllCounterStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM::getAllCounterStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSystemCounterState.html">SystemCounterState</a> &amp;&#160;</td>
          <td class="paramname"><em>systemState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSocketCounterState.html">SocketCounterState</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>socketStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classCoreCounterState.html">CoreCounterState</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coreStates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads all counter states (including system, sockets and cores) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">systemState</td><td>system counter state (return parameter) </td></tr>
    <tr><td class="paramname">socketStates</td><td>socket counter states (return parameter) </td></tr>
    <tr><td class="paramname">coreStates</td><td>core counter states (return parameter) </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classPCM.html#aabb7e0514fd741966fec461ccd9427f3">isCoreOnline()</a>.</p>

</div>
</div>
<a id="a4ed1c64e3cb00c76851e3373a1fa54a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed1c64e3cb00c76851e3373a1fa54a3">&#9670;&nbsp;</a></span>getCoreCounterState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCoreCounterState.html">CoreCounterState</a> PCM::getCoreCounterState </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>core</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the counter state of a (logical) core. </p>
<p>Be aware that during the measurement other threads may be scheduled on the same core by the operating system (this is called context-switching). The performance events caused by these threads will be counted as well.</p>
<pre class="fragment">\param core core id
\return State of counters in the core</pre> 
<p class="reference">Referenced by <a class="el" href="cpucounters_8h.html#abc0a6dbd1fb8151d5095443c0916ce78">getCoreCounterState()</a>, and <a class="el" href="classPCM.html#a794f5852662a2827b34eb16025564c70">getTickCount()</a>.</p>

</div>
</div>
<a id="a90eb072bebf4be22bce23d550983f6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90eb072bebf4be22bce23d550983f6fe">&#9670;&nbsp;</a></span>getCoreId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32 PCM::getCoreId </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>os_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines physical core of given processor ID within a socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os_id</td><td>processor identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>physical core identifier </dd></dl>

</div>
</div>
<a id="a5f8c7d4c978238706fe74ec00c803f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8c7d4c978238706fe74ec00c803f9a">&#9670;&nbsp;</a></span>getCPUModel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PCM::getCPUModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads CPU model id. </p>
<dl class="section return"><dt>Returns</dt><dd>CPU model ID </dd></dl>

<p class="reference">Referenced by <a class="el" href="cpucounters_8h.html#ab6f97a3386ac2d35dfd61148acde0a53">getDRAMConsumedJoules()</a>.</p>

</div>
</div>
<a id="afcf71f98767227aa64821a715bfab099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf71f98767227aa64821a715bfab099">&#9670;&nbsp;</a></span>getCPUStepping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PCM::getCPUStepping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads CPU stepping id. </p>
<dl class="section return"><dt>Returns</dt><dd>CPU stepping ID </dd></dl>

</div>
</div>
<a id="afbb527aac9b4a15b5437bbfc3111cdeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb527aac9b4a15b5437bbfc3111cdeb">&#9670;&nbsp;</a></span>getErrorMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; PCM::getErrorMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the error message. </p>
<p>Call this when <a class="el" href="classPCM.html#a56eedaa84893f72b1723f8d580ee3329" title="Checks the status of PCM object. ">good()</a> returns false, otherwise return an empty string </p>

<p class="reference">References <a class="el" href="cpucounters_8h.html#abc0a6dbd1fb8151d5095443c0916ce78">getCoreCounterState()</a>, <a class="el" href="cpucounters_8h.html#ad3fd926e1850510a693196af34206483">getSocketCounterState()</a>, and <a class="el" href="cpucounters_8h.html#a7a00cd524240b3c46d07ef9be7a6cdea">getSystemCounterState()</a>.</p>

</div>
</div>
<a id="a85e2036c24c34ab5eecce856382d19fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e2036c24c34ab5eecce856382d19fb">&#9670;&nbsp;</a></span>getIIOCounterState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleCounterState.html">IIOCounterState</a> PCM::getIIOCounterState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>IIOStack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the state of IIO counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket of the IIO stack </td></tr>
    <tr><td class="paramname">IIOStack</td><td>id of the IIO stack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State of IIO counter </dd></dl>

</div>
</div>
<a id="a25e8b223197728858a704d53b8ab5534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e8b223197728858a704d53b8ab5534">&#9670;&nbsp;</a></span>getIIOCounterStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM::getIIOCounterStates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>IIOStack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimpleCounterState.html">IIOCounterState</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the states of the four IIO counters in bulk (faster than four single reads) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket of the IIO stack </td></tr>
    <tr><td class="paramname">IIOStack</td><td>id of the IIO stack </td></tr>
    <tr><td class="paramname">result</td><td>states of IIO counters (array of four IIOCounterState elements) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a155611028fb95409625e44784f7b4c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155611028fb95409625e44784f7b4c7b">&#9670;&nbsp;</a></span>getInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPCM.html">PCM</a> * PCM::getInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> object. </p>
<p>Returns <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> object. If the <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> has not been created before than an instance is created. <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> is a singleton.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> object </dd></dl>

<p class="reference">Referenced by <a class="el" href="classServerPCICFGUncore.html#a42a0e1343ab38371279bf9def8123419">ServerPCICFGUncore::computeQPISpeed()</a>, <a class="el" href="utils_8h.html#ad7f085309ae89de98d2f3755d6b00d6a">exit_cleanup()</a>, <a class="el" href="cpucounters_8h.html#a963d78be64ccddb4f7686405ef4df9c1">getActiveAverageFrequency()</a>, <a class="el" href="cpucounters_8h.html#a9a351e598b8af26131611ff37b592633">getActiveRelativeFrequency()</a>, <a class="el" href="cpucounters_8h.html#a1f83dc2b6cd3a1efcd850003e26c6404">getAllIncomingQPILinkBytes()</a>, <a class="el" href="cpucounters_8h.html#a0b914c4bffa783271c276b29be582370">getAllOutgoingQPILinkBytes()</a>, <a class="el" href="cpucounters_8h.html#aa398facfd523b7dcdbf827a74970a88c">getAverageFrequency()</a>, <a class="el" href="cpucounters_8h.html#a8a7e839f24a02691d4b3509fc2adee51">getBytesReadFromEDC()</a>, <a class="el" href="cpucounters_8h.html#a0f28a32a3edeaecd916ba097aee99d7f">getBytesReadFromMC()</a>, <a class="el" href="cpucounters_8h.html#afba35ab2fa127ac0af819a1134711722">getBytesReadFromPMM()</a>, <a class="el" href="cpucounters_8h.html#aface6421f7c3e654bcf411abd7cea990">getBytesWrittenToEDC()</a>, <a class="el" href="cpucounters_8h.html#a24fce7df2ee7140db18ecfcd74fe63d1">getBytesWrittenToMC()</a>, <a class="el" href="cpucounters_8h.html#ae86f464068c1f531fd40612fa9ae0c7a">getBytesWrittenToPMM()</a>, <a class="el" href="cpucounters_8h.html#af8f7dab111f6b8cbcfa0c1b81e1860fb">getConsumedJoules()</a>, <a class="el" href="cpucounters_8h.html#abc0a6dbd1fb8151d5095443c0916ce78">getCoreCounterState()</a>, <a class="el" href="cpucounters_8h.html#a98aa8d4eb21e8a992fc181d65018e5ce">getCoreCStateResidency()</a>, <a class="el" href="cpucounters_8h.html#abaca7147e6334e13bbbc718e4a537568">getCoreIPC()</a>, <a class="el" href="cpucounters_8h.html#ab6f97a3386ac2d35dfd61148acde0a53">getDRAMConsumedJoules()</a>, <a class="el" href="cpucounters_8h.html#a996fd8a127111e06540302cf9ccb24a7">getEDCCounter()</a>, <a class="el" href="cpucounters_8h.html#aca1b1d8ba1679c4a0c394c2647428fd3">getIncomingQPILinkBytes()</a>, <a class="el" href="cpucounters_8h.html#a0ba3a5b71b7dd6b84c345f8cbc795b1c">getIncomingQPILinkUtilization()</a>, <a class="el" href="cpucounters_8h.html#a7e5434dba3a810501f289329e52b889d">getIORequestBytesFromMC()</a>, <a class="el" href="cpucounters_8h.html#a5922acedeec3c1cc67d20670f8ef0518">getL2CacheHitRatio()</a>, <a class="el" href="cpucounters_8h.html#a459367d7877d09594c2ecd85e04cae61">getL2CacheHits()</a>, <a class="el" href="cpucounters_8h.html#a291eeab262fdb93de08cdfdf50dbad58">getL2CacheMisses()</a>, <a class="el" href="cpucounters_8h.html#a7b03f0cd02862716d717e897032b7885">getL3CacheHitRatio()</a>, <a class="el" href="cpucounters_8h.html#a7ba16714ef7ed547ad8648cb5b9e52f6">getL3CacheHits()</a>, <a class="el" href="cpucounters_8h.html#ace0e3ffc23c20d0eda7663cb7e4899a2">getL3CacheHitsNoSnoop()</a>, <a class="el" href="cpucounters_8h.html#a4b1050ca9ccdd66661df556bab70fd0f">getL3CacheHitsSnoop()</a>, <a class="el" href="cpucounters_8h.html#a94118e70266db2ed7fc6b8b7b4e2c343">getL3CacheMisses()</a>, <a class="el" href="cpucounters_8h.html#a185f850a9a753d9cf4deb8299261fd4c">getL3CacheOccupancy()</a>, <a class="el" href="cpucounters_8h.html#a6791e3fe842320171cbac393e55929f6">getLLCReadMissLatency()</a>, <a class="el" href="cpucounters_8h.html#a3ba7c9267c6e0f338a59defc98ae0007">getLocalMemoryBW()</a>, <a class="el" href="cpucounters_8h.html#ab7b921e53cadd4e1504c90c400bd8b18">getLocalMemoryRequestRatio()</a>, <a class="el" href="cpucounters_8h.html#a6bdb34d102d7353421bd878da7b9ef23">getOutgoingQPILinkBytes()</a>, <a class="el" href="cpucounters_8h.html#ac7b1863133a9a711117fcb8b68d2d773">getOutgoingQPILinkUtilization()</a>, <a class="el" href="cpucounters_8h.html#a5e34f7b0326dda86b54fcb7bb84a0b38">getPackageCStateResidency()</a>, <a class="el" href="cpucounters_8h.html#a17823150d51bdebdd203dfa00b0a5f49">getQPItoMCTrafficRatio()</a>, <a class="el" href="cpucounters_8h.html#a00c97b1a7d8a7125ce7fd129cddb52e8">getRemoteMemoryBW()</a>, <a class="el" href="cpucounters_8h.html#ad3fd926e1850510a693196af34206483">getSocketCounterState()</a>, <a class="el" href="cpucounters_8h.html#ae6e948c5ad7859e3760336aa02f466bd">getSocketIncomingQPILinkBytes()</a>, <a class="el" href="cpucounters_8h.html#a7a00cd524240b3c46d07ef9be7a6cdea">getSystemCounterState()</a>, <a class="el" href="cpucounters_8h.html#a546944a165ea621d77a524b15ccd6cf1">getTotalExecUsage()</a>, <a class="el" href="utils_8h.html#a7554cbdafa9da0f374648381a31e2522">MySystem()</a>, <a class="el" href="classServerPCICFGUncore.html#acd6e859dd5eaaadf97d2c59ae70ac4a7">ServerPCICFGUncore::program()</a>, <a class="el" href="classServerPCICFGUncore.html#a0380e4ee6c10b5a7c76517a119a20b92">ServerPCICFGUncore::programServerUncoreMemoryMetrics()</a>, <a class="el" href="classServerPCICFGUncore.html#ab41eec236180d9d451fc1edc823dcc84">ServerPCICFGUncore::reportQPISpeed()</a>, <a class="el" href="utils_8h.html#afc1a4d527493068f7670f237fc448bb8">sigINT_handler()</a>, and <a class="el" href="utils_8h.html#a31614f993e86b671fc8775249db1f178">sigSTOP_handler()</a>.</p>

</div>
</div>
<a id="a2cdc063d0b3fdf7c6b81ef4e5b4c341e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdc063d0b3fdf7c6b81ef4e5b4c341e">&#9670;&nbsp;</a></span>getL3ScalingFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PCM::getL3ScalingFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>runs CPUID.0xF.0x01 to get the L3 up scaling factor to calculate L3 Occupancy Scaling factor is returned in EBX register after running the CPU instruction </p>
<dl class="section return"><dt>Returns</dt><dd>L3 up scaling factor </dd></dl>

</div>
</div>
<a id="a17084236c1d744a92adec4205415e0ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17084236c1d744a92adec4205415e0ad">&#9670;&nbsp;</a></span>getMaxIPC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PCM::getMaxIPC </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the max number of instructions per cycle. </p>
<dl class="section return"><dt>Returns</dt><dd>max number of instructions per cycle </dd></dl>

</div>
</div>
<a id="a0e1151b2a215849ab67ab2b0056e0e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1151b2a215849ab67ab2b0056e0e0f">&#9670;&nbsp;</a></span>getMaxRMID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned PCM::getMaxRMID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the max number of RMID supported by socket </p>
<dl class="section return"><dt>Returns</dt><dd>maximum number of RMID supported by socket </dd></dl>

</div>
</div>
<a id="aa6ec2128018c26d8c6dc70a41dae2080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ec2128018c26d8c6dc70a41dae2080">&#9670;&nbsp;</a></span>getMCChannels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t PCM::getMCChannels </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>controller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of detected memory channels on given integrated memory controllers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket </td></tr>
    <tr><td class="paramname">controller</td><td>controller </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83cd795814da47148632b24e485e6075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83cd795814da47148632b24e485e6075">&#9670;&nbsp;</a></span>getNominalFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64 PCM::getNominalFrequency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the nominal core frequency. </p>
<dl class="section return"><dt>Returns</dt><dd>Nominal frequency in Hz </dd></dl>

<p class="reference">Referenced by <a class="el" href="cpucounters_8h.html#a963d78be64ccddb4f7686405ef4df9c1">getActiveAverageFrequency()</a>, <a class="el" href="cpucounters_8h.html#aa398facfd523b7dcdbf827a74970a88c">getAverageFrequency()</a>, <a class="el" href="cpucounters_8h.html#a0ba3a5b71b7dd6b84c345f8cbc795b1c">getIncomingQPILinkUtilization()</a>, <a class="el" href="cpucounters_8h.html#a6bdb34d102d7353421bd878da7b9ef23">getOutgoingQPILinkBytes()</a>, <a class="el" href="cpucounters_8h.html#ac7b1863133a9a711117fcb8b68d2d773">getOutgoingQPILinkUtilization()</a>, and <a class="el" href="classPCM.html#a794f5852662a2827b34eb16025564c70">getTickCount()</a>.</p>

</div>
</div>
<a id="a18d1666c08f014378cf49c707fc978d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d1666c08f014378cf49c707fc978d1">&#9670;&nbsp;</a></span>getNumCores()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PCM::getNumCores </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads number of logical cores in the system. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of logical cores in the system </dd></dl>

<p class="reference">Referenced by <a class="el" href="cpucounters_8h.html#abaca7147e6334e13bbbc718e4a537568">getCoreIPC()</a>, <a class="el" href="cpucounters_8h.html#a0ba3a5b71b7dd6b84c345f8cbc795b1c">getIncomingQPILinkUtilization()</a>, <a class="el" href="cpucounters_8h.html#a6bdb34d102d7353421bd878da7b9ef23">getOutgoingQPILinkBytes()</a>, <a class="el" href="cpucounters_8h.html#ac7b1863133a9a711117fcb8b68d2d773">getOutgoingQPILinkUtilization()</a>, and <a class="el" href="cpucounters_8h.html#a546944a165ea621d77a524b15ccd6cf1">getTotalExecUsage()</a>.</p>

</div>
</div>
<a id="a30210eb2ddc9eee6bfe1db4b159f922b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30210eb2ddc9eee6bfe1db4b159f922b">&#9670;&nbsp;</a></span>getNumOnlineCores()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PCM::getNumOnlineCores </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads number of online logical cores in the system. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of online logical cores in the system </dd></dl>

<p class="reference">Referenced by <a class="el" href="cpucounters_8h.html#abaca7147e6334e13bbbc718e4a537568">getCoreIPC()</a>, and <a class="el" href="cpucounters_8h.html#a546944a165ea621d77a524b15ccd6cf1">getTotalExecUsage()</a>.</p>

</div>
</div>
<a id="a9b3c25455743ff4475b237d7c338d4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3c25455743ff4475b237d7c338d4a2">&#9670;&nbsp;</a></span>getNumOnlineSockets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PCM::getNumOnlineSockets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads number of online sockets (CPUs) in the system. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of online sockets in the system </dd></dl>

</div>
</div>
<a id="a7d4964e57e7692b5cc67d8b5056e5299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4964e57e7692b5cc67d8b5056e5299">&#9670;&nbsp;</a></span>getNumSockets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PCM::getNumSockets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads number of sockets (CPUs) in the system. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of sockets in the system </dd></dl>

<p class="reference">Referenced by <a class="el" href="cpucounters_8h.html#a1f83dc2b6cd3a1efcd850003e26c6404">getAllIncomingQPILinkBytes()</a>, and <a class="el" href="cpucounters_8h.html#a0b914c4bffa783271c276b29be582370">getAllOutgoingQPILinkBytes()</a>.</p>

</div>
</div>
<a id="a3b1b549672af4c14c00eb7d461c87ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1b549672af4c14c00eb7d461c87ac4">&#9670;&nbsp;</a></span>getPCIeCounterState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleCounterState.html">PCIeCounterState</a> PCM::getPCIeCounterState </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>socket_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the state of PCIe <a class="el" href="structcounter.html">counter(s)</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_</td><td>socket of the PCIe controller </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State of PCIe <a class="el" href="structcounter.html">counter(s)</a> </dd></dl>

</div>
</div>
<a id="a9bfa5b2f12f2e98382f9d8ddbc0c02e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfa5b2f12f2e98382f9d8ddbc0c02e1">&#9670;&nbsp;</a></span>getQPILinkSpeed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64 PCM::getQPILinkSpeed </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>socketNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>linkNr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return QPI Link Speed in GBytes/second. </p>
<dl class="section warning"><dt>Warning</dt><dd>Works only for Nehalem-EX (Xeon 7500) and Xeon E7 and E5 processors </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>QPI Link Speed in GBytes/second </dd></dl>

<p class="reference">Referenced by <a class="el" href="cpucounters_8h.html#a0ba3a5b71b7dd6b84c345f8cbc795b1c">getIncomingQPILinkUtilization()</a>, <a class="el" href="cpucounters_8h.html#a6bdb34d102d7353421bd878da7b9ef23">getOutgoingQPILinkBytes()</a>, and <a class="el" href="cpucounters_8h.html#ac7b1863133a9a711117fcb8b68d2d773">getOutgoingQPILinkUtilization()</a>.</p>

</div>
</div>
<a id="af0f62775b214218edf64a3f68df6c932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f62775b214218edf64a3f68df6c932">&#9670;&nbsp;</a></span>getQPILinksPerSocket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64 PCM::getQPILinksPerSocket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of Intel(r) Quick Path Interconnect(tm) links per socket. </p>
<dl class="section return"><dt>Returns</dt><dd>number of QPI links per socket </dd></dl>

</div>
</div>
<a id="a348909c5eee3df734c1784105fb97581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348909c5eee3df734c1784105fb97581">&#9670;&nbsp;</a></span>getServerUncoreCounterState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServerUncoreCounterState.html">ServerUncoreCounterState</a> PCM::getServerUncoreCounterState </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the power/energy counter state of a socket (works only on microarchitecture codename SandyBridge-EP) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State of power counters in the socket </dd></dl>

</div>
</div>
<a id="a27548ccdca19f180dcc8acd2ca484669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27548ccdca19f180dcc8acd2ca484669">&#9670;&nbsp;</a></span>getSMT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM::getSMT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if SMT (HyperThreading) is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>true iff SMT (HyperThreading) is enabled. </dd></dl>

</div>
</div>
<a id="ade00dbbd2a71ec32ae6747bfca66cd3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade00dbbd2a71ec32ae6747bfca66cd3c">&#9670;&nbsp;</a></span>getSocketCounterState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSocketCounterState.html">SocketCounterState</a> PCM::getSocketCounterState </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the counter state of a socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State of counters in the socket </dd></dl>

<p class="reference">References <a class="el" href="classPCM.html#aabb7e0514fd741966fec461ccd9427f3">isCoreOnline()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cpucounters_8h.html#ad3fd926e1850510a693196af34206483">getSocketCounterState()</a>.</p>

</div>
</div>
<a id="a015a39143b7bb87b41dc34b43a926029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015a39143b7bb87b41dc34b43a926029">&#9670;&nbsp;</a></span>getSocketId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32 PCM::getSocketId </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>core_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines socket of given core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core_id</td><td>core identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>socket identifier </dd></dl>

</div>
</div>
<a id="a603bf92fb67f294f5bc59185bc5c89cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603bf92fb67f294f5bc59185bc5c89cb">&#9670;&nbsp;</a></span>getSystemCounterState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSystemCounterState.html">SystemCounterState</a> PCM::getSystemCounterState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the counter state of the system. </p>
<p>System consists of several sockets (CPUs). <a class="el" href="classSocket.html">Socket</a> has a CPU in it. <a class="el" href="classSocket.html">Socket</a> (CPU) consists of several (logical) cores.</p>
<dl class="section return"><dt>Returns</dt><dd>State of counters in the entire system </dd></dl>

<p class="reference">References <a class="el" href="classPCM.html#aabb7e0514fd741966fec461ccd9427f3">isCoreOnline()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cpucounters_8h.html#a7a00cd524240b3c46d07ef9be7a6cdea">getSystemCounterState()</a>.</p>

</div>
</div>
<a id="ad23a4c0feeda389a1e56191a5740f95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23a4c0feeda389a1e56191a5740f95a">&#9670;&nbsp;</a></span>getSystemTopology()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSystemRoot.html">SystemRoot</a> const&amp; PCM::getSystemTopology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The system, sockets, uncores, cores and threads are structured like a tree. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to a const System object representing the root of the tree </dd></dl>

</div>
</div>
<a id="a728347cf85816c42833a1a8a1f14b861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728347cf85816c42833a1a8a1f14b861">&#9670;&nbsp;</a></span>getThreadId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32 PCM::getThreadId </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>os_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines physical thread of given processor ID within a core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os_id</td><td>processor identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>physical thread identifier </dd></dl>

</div>
</div>
<a id="a850a9aeee162133adbc4b5d8df679639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850a9aeee162133adbc4b5d8df679639">&#9670;&nbsp;</a></span>getThreadsPerCore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PCM::getThreadsPerCore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads how many hardware threads has a physical core "Hardware thread" is a logical core in a different terminology. If Intel(r) Hyperthreading(tm) is enabled then this function returns 2. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of hardware threads per physical core </dd></dl>

<p class="reference">Referenced by <a class="el" href="cpucounters_8h.html#abaca7147e6334e13bbbc718e4a537568">getCoreIPC()</a>, and <a class="el" href="cpucounters_8h.html#a546944a165ea621d77a524b15ccd6cf1">getTotalExecUsage()</a>.</p>

</div>
</div>
<a id="a794f5852662a2827b34eb16025564c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794f5852662a2827b34eb16025564c70">&#9670;&nbsp;</a></span>getTickCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64 PCM::getTickCount </td>
          <td>(</td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>multiplier</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>core</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return TSC timer value in time units. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multiplier</td><td>use 1 for seconds, 1000 for ms, 1000000 for mks, etc (default is 1000: ms) </td></tr>
    <tr><td class="paramname">core</td><td>core to read on-chip TSC value (default is 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>time counter value </dd></dl>

<p class="reference">References <a class="el" href="classPCM.html#a4ed1c64e3cb00c76851e3373a1fa54a3">getCoreCounterState()</a>, <a class="el" href="cpucounters_8h.html#a45cf07a8d3ce2c48968842554a3854f9">getInvariantTSC()</a>, and <a class="el" href="classPCM.html#a83cd795814da47148632b24e485e6075">getNominalFrequency()</a>.</p>

</div>
</div>
<a id="a0d5153c7ec05003da7d20aeea737113e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5153c7ec05003da7d20aeea737113e">&#9670;&nbsp;</a></span>getTickCountRDTSCP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64 PCM::getTickCountRDTSCP </td>
          <td>(</td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>multiplier</em> = <code>1000</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return TSC timer value in time units using rdtscp instruction from current core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multiplier</td><td>use 1 for seconds, 1000 for ms, 1000000 for mks, etc (default is 1000: ms) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Processor support is required bit 27 of cpuid EDX must be set, for Windows, Visual Studio 2010 is required </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>time counter value </dd></dl>

</div>
</div>
<a id="a2b4433865e00da98c4fa588cb1be913c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4433865e00da98c4fa588cb1be913c">&#9670;&nbsp;</a></span>getTileId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32 PCM::getTileId </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>os_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines physical tile (cores sharing L2 cache) of given processor ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os_id</td><td>processor identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>physical tile identifier </dd></dl>

</div>
</div>
<a id="aa1d4aa1ea3a38a348e27a98dd5c61fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d4aa1ea3a38a348e27a98dd5c61fda">&#9670;&nbsp;</a></span>getUArchCodename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * PCM::getUArchCodename </td>
          <td>(</td>
          <td class="paramtype">const int32&#160;</td>
          <td class="paramname"><em>cpu_model_</em> = <code>-1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a string describing the codename of the processor microarchitecture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_model_</td><td>cpu model (if no parameter provided the codename of the detected CPU is returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f1ffc2220b041f739a672b5be82361f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1ffc2220b041f739a672b5be82361f">&#9670;&nbsp;</a></span>getUncoreCounterStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM::getUncoreCounterStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSystemCounterState.html">SystemCounterState</a> &amp;&#160;</td>
          <td class="paramname"><em>systemState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSocketCounterState.html">SocketCounterState</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>socketStates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads uncore counter states (including system and sockets) but no core counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">systemState</td><td>system counter state (return parameter) </td></tr>
    <tr><td class="paramname">socketStates</td><td>socket counter states (return parameter) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56eedaa84893f72b1723f8d580ee3329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56eedaa84893f72b1723f8d580ee3329">&#9670;&nbsp;</a></span>good()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM::good </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the status of <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> object. </p>
<p>Call this method to check if <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> gained access to model specific registers. The method is deprecated, see program error code instead.</p>
<dl class="section return"><dt>Returns</dt><dd>true iff access to model specific registers works without problems </dd></dl>

</div>
</div>
<a id="a5e4cabfe4223f1d2e7e1e0da8b1179b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4cabfe4223f1d2e7e1e0da8b1179b3">&#9670;&nbsp;</a></span>initWinRing0Lib()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool PCM::initWinRing0Lib </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads and initializes Winring0 third party library for access to processor model specific and PCI configuration registers. </p>
<dl class="section return"><dt>Returns</dt><dd>returns true in case of success </dd></dl>

</div>
</div>
<a id="aabb7e0514fd741966fec461ccd9427f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb7e0514fd741966fec461ccd9427f3">&#9670;&nbsp;</a></span>isCoreOnline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM::isCoreOnline </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>os_core_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the core in online. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os_core_id</td><td>OS core id </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classPCM.html#ade92d30321a659ca54d423eaf0e30e12">getAllCounterStates()</a>, <a class="el" href="classPCM.html#ade00dbbd2a71ec32ae6747bfca66cd3c">getSocketCounterState()</a>, and <a class="el" href="classPCM.html#a603bf92fb67f294f5bc59185bc5c89cb">getSystemCounterState()</a>.</p>

</div>
</div>
<a id="a67f21fcae47cfb6153055bf922c8a981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f21fcae47cfb6153055bf922c8a981">&#9670;&nbsp;</a></span>isSocketOnline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM::isSocketOnline </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>socket_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the socket in online. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>OS socket id </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classPCM.html#a3279d88bbd5c2eab06c9c6cb6248c3c7">getCPUBrandString()</a>, and <a class="el" href="classPCM.html#a28d9a0ddb37cc4f87ac95b544cc36c9b">isAtom()</a>.</p>

</div>
</div>
<a id="aab16be3893549f5f2d782071aeaead5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab16be3893549f5f2d782071aeaead5f">&#9670;&nbsp;</a></span>isSomeCoreOfflined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM::isSomeCoreOfflined </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>runs CPUID.0xB.0x01 to get maximum logical cores (including SMT) per socket. max_lcores_per_socket is returned in EBX[15:0]. Compare this value with number of cores per socket detected in the system to see if some cores are offlined </p>
<dl class="section return"><dt>Returns</dt><dd>true iff max_lcores_per_socket == number of cores per socket detected </dd></dl>

</div>
</div>
<a id="a6a6580b296a5a0236c9e00956988c0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6580b296a5a0236c9e00956988c0fc">&#9670;&nbsp;</a></span>L3CacheOccupancyMetricAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM::L3CacheOccupancyMetricAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if L3 cache monitoring present </p>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

<p class="reference">References <a class="el" href="classPCM.html#ab1be879d2c871816ddbcfa30bb58a3e7">L3QOSMetricAvailable()</a>, and <a class="el" href="classPCM.html#ad12300d8a7096cc4258108ced23cd491">QOSMetricAvailable()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cpucounters_8h.html#a185f850a9a753d9cf4deb8299261fd4c">getL3CacheOccupancy()</a>.</p>

</div>
</div>
<a id="ab1be879d2c871816ddbcfa30bb58a3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1be879d2c871816ddbcfa30bb58a3e7">&#9670;&nbsp;</a></span>L3QOSMetricAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM::L3QOSMetricAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks L3 cache support for QOS present </p>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

<p class="reference">References <a class="el" href="classPCM.html#a8af93b231edbc31952b3b46799c28a10">isSecureBoot()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classPCM.html#af0648834f063a6bd2ea88c61a2ba286d">CoreLocalMemoryBWMetricAvailable()</a>, <a class="el" href="classPCM.html#a9b2b73d2af7c5a851e5c43df37d7fdb2">CoreRemoteMemoryBWMetricAvailable()</a>, and <a class="el" href="classPCM.html#a6a6580b296a5a0236c9e00956988c0fc">L3CacheOccupancyMetricAvailable()</a>.</p>

</div>
</div>
<a id="abae9577a1a172c944d133bef10683825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae9577a1a172c944d133bef10683825">&#9670;&nbsp;</a></span>program()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPCM.html#abebf5f22d794719dfc49155741e264e5">PCM::ErrorCode</a> PCM::program </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786">ProgramMode</a>&#160;</td>
          <td class="paramname"><em>mode_</em> = <code><a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786a0e861144f482697cfa423b012ed42451">DEFAULT_EVENTS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>parameter_</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs performance counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode_</td><td>mode of programming, see ProgramMode definition </td></tr>
    <tr><td class="paramname">parameter_</td><td>optional parameter for some of programming modes <pre class="fragment">    Call this method before you start using the performance counting routines.
</pre></td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Using this routines with other tools that <em>program</em> Performance Monitoring Units (PMUs) on CPUs is not recommended because PMU can not be shared. Tools that are known to program PMUs: Intel(r) VTune(tm), Intel(r) Performance Tuning Utility (PTU). This code may make VTune or PTU measurements invalid. VTune or PTU measurement may make measurement with this code invalid. Please enable either usage of these routines or VTune/PTU/etc. </dd></dl>

<p class="reference">References <a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786ac092b2b5f351e33046b87e5cee31f38f">CUSTOM_CORE_EVENTS</a>, and <a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786a0f2ff80b85b8f9483c7f03544f73fcbd">EXT_CUSTOM_CORE_EVENTS</a>.</p>

</div>
</div>
<a id="aa7bc59f9d7cfc87fbd4ee88aaeb6e846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bc59f9d7cfc87fbd4ee88aaeb6e846">&#9670;&nbsp;</a></span>programCbo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM::programCbo </td>
          <td>(</td>
          <td class="paramtype">const uint64 *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>opCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>nc_</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>llc_lookup_tid_filter</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>loc</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>rem</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program CBO (or CHA on SKX+) counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>array with four raw event values </td></tr>
    <tr><td class="paramname">opCode</td><td>opcode match filter </td></tr>
    <tr><td class="paramname">nc_</td><td>match non-coherent requests </td></tr>
    <tr><td class="paramname">llc_lookup_tid_filter</td><td>filter for LLC lookup event filter and TID filter (core and thread ID) </td></tr>
    <tr><td class="paramname">loc</td><td>match on local node target </td></tr>
    <tr><td class="paramname">rem</td><td>match on remote node target </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac75fcae283d8c6f0ef7085a913685f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75fcae283d8c6f0ef7085a913685f0b">&#9670;&nbsp;</a></span>programIIOCounters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM::programIIOCounters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIIOPMUCNTCTLRegister.html">IIOPMUCNTCTLRegister</a>&#160;</td>
          <td class="paramname"><em>rawEvents</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>IIOStack</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program uncore IIO events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rawEvents</td><td>events to program (raw format) </td></tr>
    <tr><td class="paramname">IIOStack</td><td>id of the IIO stack to program (-1 for all, if parameter omitted) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98ac3b31cd69a97c45078b40baa44556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ac3b31cd69a97c45078b40baa44556">&#9670;&nbsp;</a></span>programPCIeEventGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM::programPCIeEventGroup </td>
          <td>(</td>
          <td class="paramtype">eventGroup_t &amp;&#160;</td>
          <td class="paramname"><em>eventGroup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program uncore PCIe monitoring event(s) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventGroup</td><td>- events to programm for the same run </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66009c229b17597aba8d1e51db274840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66009c229b17597aba8d1e51db274840">&#9670;&nbsp;</a></span>programServerUncoreLatencyMetrics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPCM.html#abebf5f22d794719dfc49155741e264e5">PCM::ErrorCode</a> PCM::programServerUncoreLatencyMetrics </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_pmm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs uncore latency counters on microarchitectures codename SandyBridge-EP and later Xeon uarch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable_pmm</td><td>enables DDR/PMM. See possible profile values in pcm-latency.cpp example</td></tr>
  </table>
  </dd>
</dl>
<p>Call this method before you start using the latency counter routines on microarchitecture codename SandyBridge-EP and later Xeon uarch</p>
<dl class="section warning"><dt>Warning</dt><dd>After this call the memory and QPI bandwidth counters on microarchitecture codename SandyBridge-EP and later Xeon uarch will not work. </dd>
<dd>
Using this routines with other tools that <em>program</em> Performance Monitoring Units (PMUs) on CPUs is not recommended because PMU can not be shared. Tools that are known to program PMUs: Intel(r) VTune(tm), Intel(r) Performance Tuning Utility (PTU). This code may make VTune or PTU measurements invalid. VTune or PTU measurement may make measurement with this code invalid. Please enable either usage of these routines or VTune/PTU/etc. </dd></dl>

</div>
</div>
<a id="a9927f044c832bbdcd369c7bc1ad986c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9927f044c832bbdcd369c7bc1ad986c6">&#9670;&nbsp;</a></span>programServerUncoreMemoryMetrics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPCM.html#abebf5f22d794719dfc49155741e264e5">PCM::ErrorCode</a> PCM::programServerUncoreMemoryMetrics </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rankA</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rankB</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>PMM</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>PMMMixedMode</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs uncore memory counters on microarchitectures codename SandyBridge-EP and later Xeon uarch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rankA</td><td>count DIMM rank1 statistics (disables memory channel monitoring) </td></tr>
    <tr><td class="paramname">rankB</td><td>count DIMM rank2 statistics (disables memory channel monitoring) </td></tr>
    <tr><td class="paramname">PMM</td><td>monitor PMM bandwidth instead of partial writes </td></tr>
    <tr><td class="paramname">Program</td><td>events for PMM mixed mode (AppDirect + MemoryMode)</td></tr>
  </table>
  </dd>
</dl>
<p>Call this method before you start using the memory counter routines on microarchitecture codename SandyBridge-EP and later Xeon uarch</p>
<dl class="section warning"><dt>Warning</dt><dd>Using this routines with other tools that <em>program</em> Performance Monitoring Units (PMUs) on CPUs is not recommended because PMU can not be shared. Tools that are known to program PMUs: Intel(r) VTune(tm), Intel(r) Performance Tuning Utility (PTU). This code may make VTune or PTU measurements invalid. VTune or PTU measurement may make measurement with this code invalid. Please enable either usage of these routines or VTune/PTU/etc. </dd></dl>

</div>
</div>
<a id="a3a30cec6e4e7a78ec964d194e3844637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a30cec6e4e7a78ec964d194e3844637">&#9670;&nbsp;</a></span>programServerUncorePowerMetrics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPCM.html#abebf5f22d794719dfc49155741e264e5">PCM::ErrorCode</a> PCM::programServerUncorePowerMetrics </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mc_profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pcu_profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>freq_bands</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs uncore power/energy counters on microarchitectures codename SandyBridge-EP and later Xeon uarch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mc_profile</td><td>profile for integrated memory controller PMU. See possible profile values in pcm-power.cpp example </td></tr>
    <tr><td class="paramname">pcu_profile</td><td>profile for power control unit PMU. See possible profile values in pcm-power.cpp example </td></tr>
    <tr><td class="paramname">freq_bands</td><td>array of three integer values for core frequency band monitoring. See usage in pcm-power.cpp example</td></tr>
  </table>
  </dd>
</dl>
<p>Call this method before you start using the power counter routines on microarchitecture codename SandyBridge-EP and later Xeon uarch</p>
<dl class="section warning"><dt>Warning</dt><dd>After this call the memory and QPI bandwidth counters on microarchitecture codename SandyBridge-EP and later Xeon uarch will not work. </dd>
<dd>
Using this routines with other tools that <em>program</em> Performance Monitoring Units (PMUs) on CPUs is not recommended because PMU can not be shared. Tools that are known to program PMUs: Intel(r) VTune(tm), Intel(r) Performance Tuning Utility (PTU). This code may make VTune or PTU measurements invalid. VTune or PTU measurement may make measurement with this code invalid. Please enable either usage of these routines or VTune/PTU/etc. </dd></dl>

</div>
</div>
<a id="ad12300d8a7096cc4258108ced23cd491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12300d8a7096cc4258108ced23cd491">&#9670;&nbsp;</a></span>QOSMetricAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM::QOSMetricAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if QOS monitoring support present </p>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

<p class="reference">References <a class="el" href="classPCM.html#a8af93b231edbc31952b3b46799c28a10">isSecureBoot()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classPCM.html#af0648834f063a6bd2ea88c61a2ba286d">CoreLocalMemoryBWMetricAvailable()</a>, <a class="el" href="classPCM.html#a9b2b73d2af7c5a851e5c43df37d7fdb2">CoreRemoteMemoryBWMetricAvailable()</a>, and <a class="el" href="classPCM.html#a6a6580b296a5a0236c9e00956988c0fc">L3CacheOccupancyMetricAvailable()</a>.</p>

</div>
</div>
<a id="ad4f5ff2c6ce12f0fb4bb5ae1e5bd157a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f5ff2c6ce12f0fb4bb5ae1e5bd157a">&#9670;&nbsp;</a></span>resetPMU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM::resetPMU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces PMU reset. </p>
<p>If there is no chance to free up PMU from other applications you might try to call this method at your own risk. </p>

</div>
</div>
<a id="aab6624cfd942b9727136dc59a2c7df87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6624cfd942b9727136dc59a2c7df87">&#9670;&nbsp;</a></span>setupCustomCoreEventsForNuma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM::setupCustomCoreEventsForNuma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPCM_1_1ExtendedCustomCoreEventDescription.html">PCM::ExtendedCustomCoreEventDescription</a> &amp;&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup <a class="el" href="structPCM_1_1ExtendedCustomCoreEventDescription.html" title="Extended custom core event description. ">ExtendedCustomCoreEventDescription</a> object to read offcore (numa) counters for each processor type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>conf object to setup offcore MSR values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="cpucounters_8h_source.html">cpucounters.h</a></li>
<li><a class="el" href="cpucounters_8cpp.html">cpucounters.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
